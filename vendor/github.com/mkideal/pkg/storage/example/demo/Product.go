// NOTE: AUTO-GENERATED by midc, DON'T edit!!

package demo

import (
	"fmt"

	"github.com/mkideal/pkg/storage"
	"github.com/mkideal/pkg/typeconv"
	"gopkg.in/redis.v5"
)

var (
	_ = fmt.Printf
	_ = storage.Unused
	_ = typeconv.Unused
	_ = redis.Nil
)

// Table

type Product struct {
	Id    int64  `xorm:"pk BIGINT(20) autoincr" json:"id"`
	Price int32  `xorm:"INT(10) not null DEFAULT 1" json:"price"`
	Name  string `xorm:"VARCHAR(256) not null" json:"name"`
	Image string `xorm:"VARCHAR(512) not null" json:"image"`
	Desc  string `xorm:"VARCHAR(1024) not null DEFAULT 'hello'" json:"desc"`
}

func NewProduct() *Product {
	return &Product{Price: 1, Desc: "hello"}
}

func (Product) Meta() ProductMeta            { return productMetaVar }
func (Product) TableMeta() storage.TableMeta { return productMetaVar }
func (x Product) Key() interface{}           { return x.Id }
func (x *Product) SetKey(value string) error {
	return typeconv.String2Int64(&x.Id, value)
}

func (x Product) GetField(field string) (interface{}, bool) {
	switch field {
	case productMetaVar.F_price:
		return x.Price, true
	case productMetaVar.F_name:
		return x.Name, true
	case productMetaVar.F_image:
		return x.Image, true
	case productMetaVar.F_desc:
		return x.Desc, true
	}
	return nil, false
}

func (x *Product) SetField(field, value string) error {
	switch field {
	case productMetaVar.F_price:
		return typeconv.String2Int32(&x.Price, value)
	case productMetaVar.F_name:
		x.Name = value
	case productMetaVar.F_image:
		x.Image = value
	case productMetaVar.F_desc:
		x.Desc = value
	}
	return nil
}

// Meta
type ProductMeta struct {
	F_price string
	F_name  string
	F_image string
	F_desc  string
}

func (ProductMeta) Name() string     { return "product" }
func (ProductMeta) Key() string      { return "id" }
func (ProductMeta) Fields() []string { return _product_fields }

var productMetaVar = ProductMeta{
	F_price: "price",
	F_name:  "name",
	F_image: "image",
	F_desc:  "desc",
}

var _product_fields = []string{
	productMetaVar.F_price,
	productMetaVar.F_name,
	productMetaVar.F_image,
	productMetaVar.F_desc,
}

// Slice
type ProductSlice []Product

func NewProductSlice(cap int) *ProductSlice {
	s := ProductSlice(make([]Product, 0, cap))
	return &s
}

func (s ProductSlice) TableMeta() storage.TableMeta { return productMetaVar }
func (s ProductSlice) Len() int                     { return len(s) }
func (s *ProductSlice) Slice() []Product            { return []Product(*s) }

func (s *ProductSlice) New(table string, index int, key string) (storage.Table, error) {
	for len(*s) <= index {
		*s = append(*s, Product{})
	}
	x := &((*s)[index])
	err := x.SetKey(key)
	return x, err
}

// View
type ProductView struct {
	Product
}

type ProductViewSlice []ProductView

func NewProductViewSlice(cap int) *ProductViewSlice {
	s := ProductViewSlice(make([]ProductView, 0, cap))
	return &s
}

func (s ProductViewSlice) TableMeta() storage.TableMeta { return productMetaVar }
func (s ProductViewSlice) Len() int                     { return len(s) }
func (s *ProductViewSlice) Slice() []ProductView        { return []ProductView(*s) }

func (s *ProductViewSlice) New(table string, index int, key string) (storage.Table, error) {
	if table == "product" {
		for len(*s) <= index {
			x := Product{}
			*s = append(*s, ProductView{Product: x})
		}
		x := &((*s)[index].Product)
		err := x.SetKey(key)
		return x, err
	}
	v := &((*s)[index])
	for t, x := range v.tables() {
		if t == table {
			err := x.SetKey(key)
			return x, err
		}
	}
	return nil, storage.ErrTableNotFoundInView
}

var (
	ProductViewVar  = ProductView{}
	productViewRefs = map[string]storage.View{}
)

func (ProductView) TableMeta() storage.TableMeta  { return productMetaVar }
func (ProductView) Fields() storage.FieldList     { return storage.FieldSlice(productMetaVar.Fields()) }
func (ProductView) Refs() map[string]storage.View { return productViewRefs }
func (view *ProductView) tables() map[string]storage.Table {
	m := make(map[string]storage.Table)
	m["product"] = &view.Product
	return m
}

// Index
type ProductPriceIndex struct{}

var ProductPriceIndexVar = ProductPriceIndex{}

func (ProductPriceIndex) TableMeta() storage.TableMeta { return productMetaVar }
func (ProductPriceIndex) Name() string                 { return "product_price_index" }

func (index ProductPriceIndex) Update(session storage.Session, table storage.ReadonlyTable, key interface{}, updatedFields []string) error {
	if !storage.ContainsField(updatedFields, productMetaVar.F_price) {
		return nil
	}
	value, found := table.GetField(productMetaVar.F_price)
	if !found {
		return fmt.Errorf("field `%s` not found in table `%s`", productMetaVar.F_price, table.TableMeta().Name())
	}
	_price, ok := value.(int32)
	if !ok {
		return fmt.Errorf("type of field `%s` must be `int32`, but got `%T`", productMetaVar.F_price, value)
	}
	cache := session.Cache()
	_, err := cache.ZAdd(storage.JoinIndexKey(session.Name(), index), redis.Z{Member: key, Score: float64(_price)})
	return err
}

func (index ProductPriceIndex) Remove(session storage.Session, keys ...interface{}) error {
	cache := session.Cache()
	_, err := cache.ZRem(storage.JoinIndexKey(session.Name(), index), keys...)
	return err
}
