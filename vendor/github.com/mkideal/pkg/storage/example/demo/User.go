// NOTE: AUTO-GENERATED by midc, DON'T edit!!

package demo

import (
	"fmt"

	"github.com/mkideal/pkg/storage"
	"github.com/mkideal/pkg/typeconv"
	"gopkg.in/redis.v5"
)

var (
	_ = fmt.Printf
	_ = storage.Unused
	_ = typeconv.Unused
	_ = redis.Nil
)

// Table

type User struct {
	Id        int64  `xorm:"pk BIGINT(20)" json:"id"`
	Name      string `xorm:"VARCHAR(64) not null DEFAULT ''" json:"name"`
	Age       int    `xorm:"BIGINT(20)" json:"age"`
	AddrId    int64  `xorm:"BIGINT(20)" json:"addr_id"`
	ProductId int64  `xorm:"BIGINT(20)" json:"product_id"`
	IsRobot   bool   `xorm:"TINYINT(1)  DEFAULT false" json:"is_robot"`
}

func NewUser() *User {
	return &User{IsRobot: false}
}

func (User) Meta() UserMeta               { return userMetaVar }
func (User) TableMeta() storage.TableMeta { return userMetaVar }
func (x User) Key() interface{}           { return x.Id }
func (x *User) SetKey(value string) error {
	return typeconv.String2Int64(&x.Id, value)
}

func (x User) GetField(field string) (interface{}, bool) {
	switch field {
	case userMetaVar.F_name:
		return x.Name, true
	case userMetaVar.F_age:
		return x.Age, true
	case userMetaVar.F_addr_id:
		return x.AddrId, true
	case userMetaVar.F_product_id:
		return x.ProductId, true
	case userMetaVar.F_is_robot:
		return x.IsRobot, true
	}
	return nil, false
}

func (x *User) SetField(field, value string) error {
	switch field {
	case userMetaVar.F_name:
		x.Name = value
	case userMetaVar.F_age:
		return typeconv.String2Int(&x.Age, value)
	case userMetaVar.F_addr_id:
		return typeconv.String2Int64(&x.AddrId, value)
	case userMetaVar.F_product_id:
		return typeconv.String2Int64(&x.ProductId, value)
	case userMetaVar.F_is_robot:
		return typeconv.String2Bool(&x.IsRobot, value)
	}
	return nil
}

// Meta
type UserMeta struct {
	F_name       string
	F_age        string
	F_addr_id    string
	F_product_id string
	F_is_robot   string
}

func (UserMeta) Name() string     { return "user" }
func (UserMeta) Key() string      { return "id" }
func (UserMeta) Fields() []string { return _user_fields }

var userMetaVar = UserMeta{
	F_name:       "name",
	F_age:        "age",
	F_addr_id:    "addr_id",
	F_product_id: "product_id",
	F_is_robot:   "is_robot",
}

var _user_fields = []string{
	userMetaVar.F_name,
	userMetaVar.F_age,
	userMetaVar.F_addr_id,
	userMetaVar.F_product_id,
	userMetaVar.F_is_robot,
}

// Slice
type UserSlice []User

func NewUserSlice(cap int) *UserSlice {
	s := UserSlice(make([]User, 0, cap))
	return &s
}

func (s UserSlice) TableMeta() storage.TableMeta { return userMetaVar }
func (s UserSlice) Len() int                     { return len(s) }
func (s *UserSlice) Slice() []User               { return []User(*s) }

func (s *UserSlice) New(table string, index int, key string) (storage.Table, error) {
	for len(*s) <= index {
		*s = append(*s, User{})
	}
	x := &((*s)[index])
	err := x.SetKey(key)
	return x, err
}

// View
type UserView struct {
	User
	Address AddressView
	Product ProductView
}

type UserViewSlice []UserView

func NewUserViewSlice(cap int) *UserViewSlice {
	s := UserViewSlice(make([]UserView, 0, cap))
	return &s
}

func (s UserViewSlice) TableMeta() storage.TableMeta { return userMetaVar }
func (s UserViewSlice) Len() int                     { return len(s) }
func (s *UserViewSlice) Slice() []UserView           { return []UserView(*s) }

func (s *UserViewSlice) New(table string, index int, key string) (storage.Table, error) {
	if table == "user" {
		for len(*s) <= index {
			x := User{}
			*s = append(*s, UserView{User: x})
		}
		x := &((*s)[index].User)
		err := x.SetKey(key)
		return x, err
	}
	v := &((*s)[index])
	for t, x := range v.tables() {
		if t == table {
			err := x.SetKey(key)
			return x, err
		}
	}
	return nil, storage.ErrTableNotFoundInView
}

var (
	UserViewVar  = UserView{}
	userViewRefs = map[string]storage.View{

		userMetaVar.F_addr_id:    AddressViewVar,
		userMetaVar.F_product_id: ProductViewVar,
	}
)

func (UserView) TableMeta() storage.TableMeta  { return userMetaVar }
func (UserView) Fields() storage.FieldList     { return storage.FieldSlice(userMetaVar.Fields()) }
func (UserView) Refs() map[string]storage.View { return userViewRefs }
func (view *UserView) tables() map[string]storage.Table {
	m := make(map[string]storage.Table)
	v3 := &view.Address
	for t, x := range v3.tables() {
		m[t] = x
	}
	v4 := &view.Product
	for t, x := range v4.tables() {
		m[t] = x
	}
	m["user"] = &view.User
	return m
}

// Index
type UserAgeIndex struct{}

var UserAgeIndexVar = UserAgeIndex{}

func (UserAgeIndex) TableMeta() storage.TableMeta { return userMetaVar }
func (UserAgeIndex) Name() string                 { return "user_age_index" }

func (index UserAgeIndex) Update(session storage.Session, table storage.ReadonlyTable, key interface{}, updatedFields []string) error {
	if !storage.ContainsField(updatedFields, userMetaVar.F_age) {
		return nil
	}
	value, found := table.GetField(userMetaVar.F_age)
	if !found {
		return fmt.Errorf("field `%s` not found in table `%s`", userMetaVar.F_age, table.TableMeta().Name())
	}
	_age, ok := value.(int)
	if !ok {
		return fmt.Errorf("type of field `%s` must be `int`, but got `%T`", userMetaVar.F_age, value)
	}
	cache := session.Cache()
	_, err := cache.ZAdd(storage.JoinIndexKey(session.Name(), index), redis.Z{Member: key, Score: float64(_age)})
	return err
}

func (index UserAgeIndex) Remove(session storage.Session, keys ...interface{}) error {
	cache := session.Cache()
	_, err := cache.ZRem(storage.JoinIndexKey(session.Name(), index), keys...)
	return err
}

// Index
type UserAddrIndex struct{}

var UserAddrIndexVar = UserAddrIndex{}

func (UserAddrIndex) TableMeta() storage.TableMeta { return userMetaVar }
func (UserAddrIndex) Name() string                 { return "user_addr_index" }

func (index UserAddrIndex) Update(session storage.Session, table storage.ReadonlyTable, key interface{}, updatedFields []string) error {
	if !storage.ContainsField(updatedFields, userMetaVar.F_addr_id) {
		return nil
	}
	value, found := table.GetField(userMetaVar.F_addr_id)
	if !found {
		return fmt.Errorf("field `%s` not found in table `%s`", userMetaVar.F_addr_id, table.TableMeta().Name())
	}
	_addr_id, ok := value.(int64)
	if !ok {
		return fmt.Errorf("type of field `%s` must be `int64`, but got `%T`", userMetaVar.F_addr_id, value)
	}
	cache := session.Cache()
	_, err := cache.ZAdd(storage.JoinIndexKey(session.Name(), index), redis.Z{Member: key, Score: float64(_addr_id)})
	return err
}

func (index UserAddrIndex) Remove(session storage.Session, keys ...interface{}) error {
	cache := session.Cache()
	_, err := cache.ZRem(storage.JoinIndexKey(session.Name(), index), keys...)
	return err
}
