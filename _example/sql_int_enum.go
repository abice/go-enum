// Code generated by go-enum DO NOT EDIT.
// Version: example
// Revision: example
// Build Date: example
// Built By: example

package example

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strconv"
)

const (
	// ImageTypeJpeg is a ImageType of type Jpeg.
	ImageTypeJpeg ImageType = iota
	// ImageTypeJpg is a ImageType of type Jpg.
	ImageTypeJpg
	// ImageTypePng is a ImageType of type Png.
	ImageTypePng
	// ImageTypeTiff is a ImageType of type Tiff.
	ImageTypeTiff
	// ImageTypeGif is a ImageType of type Gif.
	ImageTypeGif
)

var ErrInvalidImageType = errors.New("not a valid ImageType")

const _imageTypeName = "jpegjpgpngtiffgif"

var _imageTypeMap = map[ImageType]string{
	ImageTypeJpeg: _imageTypeName[0:4],
	ImageTypeJpg:  _imageTypeName[4:7],
	ImageTypePng:  _imageTypeName[7:10],
	ImageTypeTiff: _imageTypeName[10:14],
	ImageTypeGif:  _imageTypeName[14:17],
}

// String implements the Stringer interface.
func (x ImageType) String() string {
	if str, ok := _imageTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ImageType(%d)", x)
}

var _imageTypeValue = map[string]ImageType{
	_imageTypeName[0:4]:   ImageTypeJpeg,
	_imageTypeName[4:7]:   ImageTypeJpg,
	_imageTypeName[7:10]:  ImageTypePng,
	_imageTypeName[10:14]: ImageTypeTiff,
	_imageTypeName[14:17]: ImageTypeGif,
}

// ParseImageType attempts to convert a string to a ImageType.
func ParseImageType(name string) (ImageType, error) {
	if x, ok := _imageTypeValue[name]; ok {
		return x, nil
	}
	return ImageType(0), fmt.Errorf("%s is %w", name, ErrInvalidImageType)
}

var ErrImageTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ImageType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ImageType(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = ImageType(v)
	case string:
		*x, err = ParseImageType(v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(v); verr == nil {
				*x, err = ImageType(val), nil
			}
		}
	case []byte:
		*x, err = ParseImageType(string(v))
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(string(v)); verr == nil {
				*x, err = ImageType(val), nil
			}
		}
	case ImageType:
		*x = v
	case int:
		*x = ImageType(v)
	case *ImageType:
		if v == nil {
			return ErrImageTypeNilPtr
		}
		*x = *v
	case uint:
		*x = ImageType(v)
	case uint64:
		*x = ImageType(v)
	case *int:
		if v == nil {
			return ErrImageTypeNilPtr
		}
		*x = ImageType(*v)
	case *int64:
		if v == nil {
			return ErrImageTypeNilPtr
		}
		*x = ImageType(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = ImageType(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return ErrImageTypeNilPtr
		}
		*x = ImageType(*v)
	case *uint:
		if v == nil {
			return ErrImageTypeNilPtr
		}
		*x = ImageType(*v)
	case *uint64:
		if v == nil {
			return ErrImageTypeNilPtr
		}
		*x = ImageType(*v)
	case *string:
		if v == nil {
			return ErrImageTypeNilPtr
		}
		*x, err = ParseImageType(*v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(*v); verr == nil {
				*x, err = ImageType(val), nil
			}
		}
	}

	return
}

// Value implements the driver Valuer interface.
func (x ImageType) Value() (driver.Value, error) {
	return int64(x), nil
}

type NullImageType struct {
	ImageType ImageType
	Valid     bool
}

func NewNullImageType(val interface{}) (x NullImageType) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Scan implements the Scanner interface.
func (x *NullImageType) Scan(value interface{}) (err error) {
	if value == nil {
		x.ImageType, x.Valid = ImageType(0), false
		return
	}

	err = x.ImageType.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullImageType) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return int64(x.ImageType), nil
}
