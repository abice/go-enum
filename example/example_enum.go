// Code generated by go-enum DO NOT EDIT.
// Version: example
// Revision: example
// Build Date: example
// Built By: example

//go:build example
// +build example

package example

import (
	"fmt"
	"strings"
)

const (
	// MakeToyota is a Make of type Toyota.
	MakeToyota Make = iota
	// Skipped value.
	_
	// MakeChevy is a Make of type Chevy.
	MakeChevy
	// Skipped value.
	_
	// MakeFord is a Make of type Ford.
	MakeFord
	// Skipped value.
	_
	// MakeTesla is a Make of type Tesla.
	MakeTesla
	// Skipped value.
	_
	// MakeHyundai is a Make of type Hyundai.
	MakeHyundai
	// Skipped value.
	_
	// MakeNissan is a Make of type Nissan.
	MakeNissan
	// Skipped value.
	_
	// MakeJaguar is a Make of type Jaguar.
	MakeJaguar
	// Skipped value.
	_
	// MakeAudi is a Make of type Audi.
	MakeAudi
	// Skipped value.
	_
	// MakeBMW is a Make of type BMW.
	MakeBMW
	// Skipped value.
	_
	// MakeMercedesBenz is a Make of type Mercedes-Benz.
	MakeMercedesBenz
	// Skipped value.
	_
	// MakeVolkswagon is a Make of type Volkswagon.
	MakeVolkswagon
)

var ErrInvalidMake = fmt.Errorf("not a valid Make, try [%s]", strings.Join(_MakeNames, ", "))

const _MakeName = "ToyotaChevyFordTeslaHyundaiNissanJaguarAudiBMWMercedes-BenzVolkswagon"

var _MakeNames = []string{
	_MakeName[0:6],
	_MakeName[6:11],
	_MakeName[11:15],
	_MakeName[15:20],
	_MakeName[20:27],
	_MakeName[27:33],
	_MakeName[33:39],
	_MakeName[39:43],
	_MakeName[43:46],
	_MakeName[46:59],
	_MakeName[59:69],
}

// MakeNames returns a list of possible string values of Make.
func MakeNames() []string {
	tmp := make([]string, len(_MakeNames))
	copy(tmp, _MakeNames)
	return tmp
}

// MakeValues returns a list of the values for Make
func MakeValues() []Make {
	return []Make{
		MakeToyota,
		MakeChevy,
		MakeFord,
		MakeTesla,
		MakeHyundai,
		MakeNissan,
		MakeJaguar,
		MakeAudi,
		MakeBMW,
		MakeMercedesBenz,
		MakeVolkswagon,
	}
}

var _MakeMap = map[Make]string{
	MakeToyota:       _MakeName[0:6],
	MakeChevy:        _MakeName[6:11],
	MakeFord:         _MakeName[11:15],
	MakeTesla:        _MakeName[15:20],
	MakeHyundai:      _MakeName[20:27],
	MakeNissan:       _MakeName[27:33],
	MakeJaguar:       _MakeName[33:39],
	MakeAudi:         _MakeName[39:43],
	MakeBMW:          _MakeName[43:46],
	MakeMercedesBenz: _MakeName[46:59],
	MakeVolkswagon:   _MakeName[59:69],
}

// String implements the Stringer interface.
func (x Make) String() string {
	if str, ok := _MakeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Make(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Make) IsValid() bool {
	_, ok := _MakeMap[x]
	return ok
}

var _MakeValue = map[string]Make{
	_MakeName[0:6]:                    MakeToyota,
	strings.ToLower(_MakeName[0:6]):   MakeToyota,
	_MakeName[6:11]:                   MakeChevy,
	strings.ToLower(_MakeName[6:11]):  MakeChevy,
	_MakeName[11:15]:                  MakeFord,
	strings.ToLower(_MakeName[11:15]): MakeFord,
	_MakeName[15:20]:                  MakeTesla,
	strings.ToLower(_MakeName[15:20]): MakeTesla,
	_MakeName[20:27]:                  MakeHyundai,
	strings.ToLower(_MakeName[20:27]): MakeHyundai,
	_MakeName[27:33]:                  MakeNissan,
	strings.ToLower(_MakeName[27:33]): MakeNissan,
	_MakeName[33:39]:                  MakeJaguar,
	strings.ToLower(_MakeName[33:39]): MakeJaguar,
	_MakeName[39:43]:                  MakeAudi,
	strings.ToLower(_MakeName[39:43]): MakeAudi,
	_MakeName[43:46]:                  MakeBMW,
	strings.ToLower(_MakeName[43:46]): MakeBMW,
	_MakeName[46:59]:                  MakeMercedesBenz,
	strings.ToLower(_MakeName[46:59]): MakeMercedesBenz,
	_MakeName[59:69]:                  MakeVolkswagon,
	strings.ToLower(_MakeName[59:69]): MakeVolkswagon,
}

// ParseMake attempts to convert a string to a Make.
func ParseMake(name string) (Make, error) {
	if x, ok := _MakeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _MakeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Make(0), fmt.Errorf("%s is %w", name, ErrInvalidMake)
}

// MarshalText implements the text marshaller method.
func (x Make) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Make) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMake(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Make) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

// Set implements the Golang flag.Value interface func.
func (x *Make) Set(val string) error {
	v, err := ParseMake(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *Make) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *Make) Type() string {
	return "Make"
}

const (
	// NoZerosStart is a NoZeros of type Start.
	NoZerosStart NoZeros = iota + 20
	// NoZerosMiddle is a NoZeros of type Middle.
	NoZerosMiddle
	// NoZerosEnd is a NoZeros of type End.
	NoZerosEnd
	// NoZerosPs is a NoZeros of type Ps.
	NoZerosPs
	// NoZerosPps is a NoZeros of type Pps.
	NoZerosPps
	// NoZerosPpps is a NoZeros of type Ppps.
	NoZerosPpps
)

var ErrInvalidNoZeros = fmt.Errorf("not a valid NoZeros, try [%s]", strings.Join(_NoZerosNames, ", "))

const _NoZerosName = "startmiddleendpsppsppps"

var _NoZerosNames = []string{
	_NoZerosName[0:5],
	_NoZerosName[5:11],
	_NoZerosName[11:14],
	_NoZerosName[14:16],
	_NoZerosName[16:19],
	_NoZerosName[19:23],
}

// NoZerosNames returns a list of possible string values of NoZeros.
func NoZerosNames() []string {
	tmp := make([]string, len(_NoZerosNames))
	copy(tmp, _NoZerosNames)
	return tmp
}

// NoZerosValues returns a list of the values for NoZeros
func NoZerosValues() []NoZeros {
	return []NoZeros{
		NoZerosStart,
		NoZerosMiddle,
		NoZerosEnd,
		NoZerosPs,
		NoZerosPps,
		NoZerosPpps,
	}
}

var _NoZerosMap = map[NoZeros]string{
	NoZerosStart:  _NoZerosName[0:5],
	NoZerosMiddle: _NoZerosName[5:11],
	NoZerosEnd:    _NoZerosName[11:14],
	NoZerosPs:     _NoZerosName[14:16],
	NoZerosPps:    _NoZerosName[16:19],
	NoZerosPpps:   _NoZerosName[19:23],
}

// String implements the Stringer interface.
func (x NoZeros) String() string {
	if str, ok := _NoZerosMap[x]; ok {
		return str
	}
	return fmt.Sprintf("NoZeros(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x NoZeros) IsValid() bool {
	_, ok := _NoZerosMap[x]
	return ok
}

var _NoZerosValue = map[string]NoZeros{
	_NoZerosName[0:5]:                    NoZerosStart,
	strings.ToLower(_NoZerosName[0:5]):   NoZerosStart,
	_NoZerosName[5:11]:                   NoZerosMiddle,
	strings.ToLower(_NoZerosName[5:11]):  NoZerosMiddle,
	_NoZerosName[11:14]:                  NoZerosEnd,
	strings.ToLower(_NoZerosName[11:14]): NoZerosEnd,
	_NoZerosName[14:16]:                  NoZerosPs,
	strings.ToLower(_NoZerosName[14:16]): NoZerosPs,
	_NoZerosName[16:19]:                  NoZerosPps,
	strings.ToLower(_NoZerosName[16:19]): NoZerosPps,
	_NoZerosName[19:23]:                  NoZerosPpps,
	strings.ToLower(_NoZerosName[19:23]): NoZerosPpps,
}

// ParseNoZeros attempts to convert a string to a NoZeros.
func ParseNoZeros(name string) (NoZeros, error) {
	if x, ok := _NoZerosValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _NoZerosValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return NoZeros(0), fmt.Errorf("%s is %w", name, ErrInvalidNoZeros)
}

// MarshalText implements the text marshaller method.
func (x NoZeros) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *NoZeros) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseNoZeros(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *NoZeros) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

// Set implements the Golang flag.Value interface func.
func (x *NoZeros) Set(val string) error {
	v, err := ParseNoZeros(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *NoZeros) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *NoZeros) Type() string {
	return "NoZeros"
}
