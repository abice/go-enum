// Code generated by go-enum DO NOT EDIT.
// Version: example
// Revision: example
// Build Date: example
// Built By: example

//go:build example
// +build example

package example

import (
	"database/sql/driver"
	"errors"
	"fmt"
)

const (
	// UnparsedSqlStringA is a UnparsedSqlString of type A.
	UnparsedSqlStringA UnparsedSqlString = "A"
	// UnparsedSqlStringB is a UnparsedSqlString of type B.
	UnparsedSqlStringB UnparsedSqlString = "B"
	// UnparsedSqlStringC is a UnparsedSqlString of type C.
	UnparsedSqlStringC UnparsedSqlString = "C"
	// UnparsedSqlStringD is a UnparsedSqlString of type D.
	UnparsedSqlStringD UnparsedSqlString = "D"
	// UnparsedSqlStringE is a UnparsedSqlString of type E.
	UnparsedSqlStringE UnparsedSqlString = "E"
)

var ErrInvalidUnparsedSqlString = errors.New("not a valid UnparsedSqlString")

// String implements the Stringer interface.
func (x UnparsedSqlString) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x UnparsedSqlString) IsValid() bool {
	_, err := parseUnparsedSqlString(string(x))
	return err == nil
}

var _UnparsedSqlStringValue = map[string]UnparsedSqlString{
	"A": UnparsedSqlStringA,
	"B": UnparsedSqlStringB,
	"C": UnparsedSqlStringC,
	"D": UnparsedSqlStringD,
	"E": UnparsedSqlStringE,
}

// parseUnparsedSqlString attempts to convert a string to a UnparsedSqlString.
func parseUnparsedSqlString(name string) (UnparsedSqlString, error) {
	if x, ok := _UnparsedSqlStringValue[name]; ok {
		return x, nil
	}
	return UnparsedSqlString(""), fmt.Errorf("%s is %w", name, ErrInvalidUnparsedSqlString)
}

var errUnparsedSqlStringNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *UnparsedSqlString) Scan(value interface{}) (err error) {
	if value == nil {
		*x = UnparsedSqlString("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = parseUnparsedSqlString(v)
	case []byte:
		*x, err = parseUnparsedSqlString(string(v))
	case UnparsedSqlString:
		*x = v
	case *UnparsedSqlString:
		if v == nil {
			return errUnparsedSqlStringNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errUnparsedSqlStringNilPtr
		}
		*x, err = parseUnparsedSqlString(*v)
	default:
		return errors.New("invalid type for UnparsedSqlString")
	}

	return
}

// Value implements the driver Valuer interface.
func (x UnparsedSqlString) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// UnparsedSqlValuesA is a UnparsedSqlValues of type A.
	UnparsedSqlValuesA UnparsedSqlValues = iota
	// UnparsedSqlValuesB is a UnparsedSqlValues of type B.
	UnparsedSqlValuesB
	// UnparsedSqlValuesC is a UnparsedSqlValues of type C.
	UnparsedSqlValuesC
	// UnparsedSqlValuesD is a UnparsedSqlValues of type D.
	UnparsedSqlValuesD
	// UnparsedSqlValuesE is a UnparsedSqlValues of type E.
	UnparsedSqlValuesE
)

var ErrInvalidUnparsedSqlValues = errors.New("not a valid UnparsedSqlValues")

const _UnparsedSqlValuesName = "ABCDE"

var _UnparsedSqlValuesMap = map[UnparsedSqlValues]string{
	UnparsedSqlValuesA: _UnparsedSqlValuesName[0:1],
	UnparsedSqlValuesB: _UnparsedSqlValuesName[1:2],
	UnparsedSqlValuesC: _UnparsedSqlValuesName[2:3],
	UnparsedSqlValuesD: _UnparsedSqlValuesName[3:4],
	UnparsedSqlValuesE: _UnparsedSqlValuesName[4:5],
}

// String implements the Stringer interface.
func (x UnparsedSqlValues) String() string {
	if str, ok := _UnparsedSqlValuesMap[x]; ok {
		return str
	}
	return fmt.Sprintf("UnparsedSqlValues(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x UnparsedSqlValues) IsValid() bool {
	_, ok := _UnparsedSqlValuesMap[x]
	return ok
}

var _UnparsedSqlValuesValue = map[string]UnparsedSqlValues{
	_UnparsedSqlValuesName[0:1]: UnparsedSqlValuesA,
	_UnparsedSqlValuesName[1:2]: UnparsedSqlValuesB,
	_UnparsedSqlValuesName[2:3]: UnparsedSqlValuesC,
	_UnparsedSqlValuesName[3:4]: UnparsedSqlValuesD,
	_UnparsedSqlValuesName[4:5]: UnparsedSqlValuesE,
}

// parseUnparsedSqlValues attempts to convert a string to a UnparsedSqlValues.
func parseUnparsedSqlValues(name string) (UnparsedSqlValues, error) {
	if x, ok := _UnparsedSqlValuesValue[name]; ok {
		return x, nil
	}
	return UnparsedSqlValues(0), fmt.Errorf("%s is %w", name, ErrInvalidUnparsedSqlValues)
}

var errUnparsedSqlValuesNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *UnparsedSqlValues) Scan(value interface{}) (err error) {
	if value == nil {
		*x = UnparsedSqlValues(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = UnparsedSqlValues(v)
	case string:
		*x, err = parseUnparsedSqlValues(v)
	case []byte:
		*x, err = parseUnparsedSqlValues(string(v))
	case UnparsedSqlValues:
		*x = v
	case int:
		*x = UnparsedSqlValues(v)
	case *UnparsedSqlValues:
		if v == nil {
			return errUnparsedSqlValuesNilPtr
		}
		*x = *v
	case uint:
		*x = UnparsedSqlValues(v)
	case uint64:
		*x = UnparsedSqlValues(v)
	case *int:
		if v == nil {
			return errUnparsedSqlValuesNilPtr
		}
		*x = UnparsedSqlValues(*v)
	case *int64:
		if v == nil {
			return errUnparsedSqlValuesNilPtr
		}
		*x = UnparsedSqlValues(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = UnparsedSqlValues(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errUnparsedSqlValuesNilPtr
		}
		*x = UnparsedSqlValues(*v)
	case *uint:
		if v == nil {
			return errUnparsedSqlValuesNilPtr
		}
		*x = UnparsedSqlValues(*v)
	case *uint64:
		if v == nil {
			return errUnparsedSqlValuesNilPtr
		}
		*x = UnparsedSqlValues(*v)
	case *string:
		if v == nil {
			return errUnparsedSqlValuesNilPtr
		}
		*x, err = parseUnparsedSqlValues(*v)
	}

	return
}

// Value implements the driver Valuer interface.
func (x UnparsedSqlValues) Value() (driver.Value, error) {
	return x.String(), nil
}
