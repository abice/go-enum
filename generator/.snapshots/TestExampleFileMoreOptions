([]string) (len=2616) {
  (string) (len=41) "// Code generated by go-enum DO NOT EDIT.",
  (string) (len=13) "// Version: -",
  (string) (len=14) "// Revision: -",
  (string) (len=16) "// Build Date: -",
  (string) (len=14) "// Built By: -",
  (string) "",
  (string) (len=17) "package generator",
  (string) "",
  (string) (len=8) "import (",
  (string) (len=22) "\t\"database/sql/driver\"",
  (string) (len=9) "\t\"errors\"",
  (string) (len=6) "\t\"fmt\"",
  (string) (len=10) "\t\"strings\"",
  (string) (len=1) ")",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=38) "\t// AnimalCat is a Animal of type Cat.",
  (string) (len=24) "\tAnimalCat Animal = iota",
  (string) (len=38) "\t// AnimalDog is a Animal of type Dog.",
  (string) (len=10) "\tAnimalDog",
  (string) (len=40) "\t// AnimalFish is a Animal of type Fish.",
  (string) (len=11) "\tAnimalFish",
  (string) (len=1) ")",
  (string) "",
  (string) (len=99) "var ErrInvalidAnimal = fmt.Errorf(\"not a valid Animal, try [%s]\", strings.Join(_AnimalNames, \", \"))",
  (string) "",
  (string) (len=32) "const _AnimalName = \"catdogfish\"",
  (string) "",
  (string) (len=28) "var _AnimalNames = []string{",
  (string) (len=18) "\t_AnimalName[0:3],",
  (string) (len=18) "\t_AnimalName[3:6],",
  (string) (len=19) "\t_AnimalName[6:10],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// AnimalNames returns a list of possible string values of Animal.",
  (string) (len=29) "func AnimalNames() []string {",
  (string) (len=41) "\ttmp := make([]string, len(_AnimalNames))",
  (string) (len=24) "\tcopy(tmp, _AnimalNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=35) "var _AnimalMap = map[Animal]string{",
  (string) (len=30) "\tAnimalCat:  _AnimalName[0:3],",
  (string) (len=30) "\tAnimalDog:  _AnimalName[3:6],",
  (string) (len=31) "\tAnimalFish: _AnimalName[6:10],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=33) "func (x Animal) String() string {",
  (string) (len=34) "\tif str, ok := _AnimalMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=36) "\treturn fmt.Sprintf(\"Animal(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=32) "func (x Animal) IsValid() bool {",
  (string) (len=23) "\t_, ok := _AnimalMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=37) "var _AnimalValue = map[string]Animal{",
  (string) (len=47) "\t_AnimalName[0:3]:                   AnimalCat,",
  (string) (len=47) "\tstrings.ToLower(_AnimalName[0:3]):  AnimalCat,",
  (string) (len=47) "\t_AnimalName[3:6]:                   AnimalDog,",
  (string) (len=47) "\tstrings.ToLower(_AnimalName[3:6]):  AnimalDog,",
  (string) (len=48) "\t_AnimalName[6:10]:                  AnimalFish,",
  (string) (len=48) "\tstrings.ToLower(_AnimalName[6:10]): AnimalFish,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=56) "// ParseAnimal attempts to convert a string to a Animal.",
  (string) (len=47) "func ParseAnimal(name string) (Animal, error) {",
  (string) (len=37) "\tif x, ok := _AnimalValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=54) "\tif x, ok := _AnimalValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=65) "\treturn Animal(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidAnimal)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=77) "// MustParseAnimal converts a string to a Animal, and panics if is not valid.",
  (string) (len=42) "func MustParseAnimal(name string) Animal {",
  (string) (len=30) "\tval, err := ParseAnimal(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=47) "func (x Animal) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=51) "func (x *Animal) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=30) "\ttmp, err := ParseAnimal(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=92) "var errAnimalNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=54) "func (x *Animal) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=16) "\t\t*x = Animal(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=16) "\t\t*x = Animal(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=26) "\t\t*x, err = ParseAnimal(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=34) "\t\t*x, err = ParseAnimal(string(v))",
  (string) (len=13) "\tcase Animal:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=16) "\t\t*x = Animal(v)",
  (string) (len=14) "\tcase *Animal:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=25) "\t\t\treturn errAnimalNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=16) "\t\t*x = Animal(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=16) "\t\t*x = Animal(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=25) "\t\t\treturn errAnimalNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=17) "\t\t*x = Animal(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=25) "\t\t\treturn errAnimalNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=17) "\t\t*x = Animal(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=16) "\t\t*x = Animal(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=25) "\t\t\treturn errAnimalNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=17) "\t\t*x = Animal(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=25) "\t\t\treturn errAnimalNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=17) "\t\t*x = Animal(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=25) "\t\t\treturn errAnimalNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=17) "\t\t*x = Animal(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=25) "\t\t\treturn errAnimalNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=27) "\t\t*x, err = ParseAnimal(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=47) "func (x Animal) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=32) "func ParseAnimalExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=50) "\t// CasesTest_lower is a Cases of type Test_lower.",
  (string) (len=29) "\tCasesTest_lower Cases = iota",
  (string) (len=54) "\t// CasesTest_capital is a Cases of type Test_capital.",
  (string) (len=18) "\tCasesTest_capital",
  (string) (len=72) "\t// CasesAnotherLowerCaseStart is a Cases of type AnotherLowerCaseStart.",
  (string) (len=27) "\tCasesAnotherLowerCaseStart",
  (string) (len=1) ")",
  (string) "",
  (string) (len=96) "var ErrInvalidCases = fmt.Errorf(\"not a valid Cases, try [%s]\", strings.Join(_CasesNames, \", \"))",
  (string) "",
  (string) (len=64) "const _CasesName = \"test_lowertest_capitalanotherlowercasestart\"",
  (string) "",
  (string) (len=27) "var _CasesNames = []string{",
  (string) (len=18) "\t_CasesName[0:10],",
  (string) (len=19) "\t_CasesName[10:22],",
  (string) (len=19) "\t_CasesName[22:43],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=64) "// CasesNames returns a list of possible string values of Cases.",
  (string) (len=28) "func CasesNames() []string {",
  (string) (len=40) "\ttmp := make([]string, len(_CasesNames))",
  (string) (len=23) "\tcopy(tmp, _CasesNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=33) "var _CasesMap = map[Cases]string{",
  (string) (len=46) "\tCasesTest_lower:            _CasesName[0:10],",
  (string) (len=47) "\tCasesTest_capital:          _CasesName[10:22],",
  (string) (len=47) "\tCasesAnotherLowerCaseStart: _CasesName[22:43],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=32) "func (x Cases) String() string {",
  (string) (len=33) "\tif str, ok := _CasesMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=35) "\treturn fmt.Sprintf(\"Cases(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=31) "func (x Cases) IsValid() bool {",
  (string) (len=22) "\t_, ok := _CasesMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=35) "var _CasesValue = map[string]Cases{",
  (string) (len=53) "\t_CasesName[0:10]:                   CasesTest_lower,",
  (string) (len=53) "\tstrings.ToLower(_CasesName[0:10]):  CasesTest_lower,",
  (string) (len=55) "\t_CasesName[10:22]:                  CasesTest_capital,",
  (string) (len=55) "\tstrings.ToLower(_CasesName[10:22]): CasesTest_capital,",
  (string) (len=64) "\t_CasesName[22:43]:                  CasesAnotherLowerCaseStart,",
  (string) (len=64) "\tstrings.ToLower(_CasesName[22:43]): CasesAnotherLowerCaseStart,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=54) "// ParseCases attempts to convert a string to a Cases.",
  (string) (len=45) "func ParseCases(name string) (Cases, error) {",
  (string) (len=36) "\tif x, ok := _CasesValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=53) "\tif x, ok := _CasesValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=63) "\treturn Cases(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidCases)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=75) "// MustParseCases converts a string to a Cases, and panics if is not valid.",
  (string) (len=40) "func MustParseCases(name string) Cases {",
  (string) (len=29) "\tval, err := ParseCases(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=46) "func (x Cases) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=50) "func (x *Cases) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=29) "\ttmp, err := ParseCases(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=91) "var errCasesNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=53) "func (x *Cases) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=15) "\t\t*x = Cases(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=15) "\t\t*x = Cases(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=25) "\t\t*x, err = ParseCases(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=33) "\t\t*x, err = ParseCases(string(v))",
  (string) (len=12) "\tcase Cases:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=15) "\t\t*x = Cases(v)",
  (string) (len=13) "\tcase *Cases:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errCasesNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=15) "\t\t*x = Cases(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=15) "\t\t*x = Cases(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errCasesNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Cases(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errCasesNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Cases(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\t*x = Cases(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errCasesNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Cases(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errCasesNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Cases(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errCasesNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Cases(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errCasesNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=26) "\t\t*x, err = ParseCases(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=46) "func (x Cases) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=31) "func ParseCasesExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=40) "\t// ColorBlack is a Color of type Black.",
  (string) (len=24) "\tColorBlack Color = iota",
  (string) (len=40) "\t// ColorWhite is a Color of type White.",
  (string) (len=11) "\tColorWhite",
  (string) (len=36) "\t// ColorRed is a Color of type Red.",
  (string) (len=9) "\tColorRed",
  (string) (len=40) "\t// ColorGreen is a Color of type Green.",
  (string) (len=11) "\tColorGreen",
  (string) (len=38) "\t// ColorBlue is a Color of type Blue.",
  (string) (len=28) "\tColorBlue Color = iota + 29",
  (string) (len=38) "\t// ColorGrey is a Color of type Grey.",
  (string) (len=10) "\tColorGrey",
  (string) (len=42) "\t// ColorYellow is a Color of type Yellow.",
  (string) (len=12) "\tColorYellow",
  (string) (len=1) ")",
  (string) "",
  (string) (len=96) "var ErrInvalidColor = fmt.Errorf(\"not a valid Color, try [%s]\", strings.Join(_ColorNames, \", \"))",
  (string) "",
  (string) (len=53) "const _ColorName = \"blackwhiteredgreenbluegreyyellow\"",
  (string) "",
  (string) (len=27) "var _ColorNames = []string{",
  (string) (len=17) "\t_ColorName[0:5],",
  (string) (len=18) "\t_ColorName[5:10],",
  (string) (len=19) "\t_ColorName[10:13],",
  (string) (len=19) "\t_ColorName[13:18],",
  (string) (len=19) "\t_ColorName[18:22],",
  (string) (len=19) "\t_ColorName[22:26],",
  (string) (len=19) "\t_ColorName[26:32],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=64) "// ColorNames returns a list of possible string values of Color.",
  (string) (len=28) "func ColorNames() []string {",
  (string) (len=40) "\ttmp := make([]string, len(_ColorNames))",
  (string) (len=23) "\tcopy(tmp, _ColorNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=33) "var _ColorMap = map[Color]string{",
  (string) (len=30) "\tColorBlack:  _ColorName[0:5],",
  (string) (len=31) "\tColorWhite:  _ColorName[5:10],",
  (string) (len=32) "\tColorRed:    _ColorName[10:13],",
  (string) (len=32) "\tColorGreen:  _ColorName[13:18],",
  (string) (len=32) "\tColorBlue:   _ColorName[18:22],",
  (string) (len=32) "\tColorGrey:   _ColorName[22:26],",
  (string) (len=32) "\tColorYellow: _ColorName[26:32],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=32) "func (x Color) String() string {",
  (string) (len=33) "\tif str, ok := _ColorMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=35) "\treturn fmt.Sprintf(\"Color(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=31) "func (x Color) IsValid() bool {",
  (string) (len=22) "\t_, ok := _ColorMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=35) "var _ColorValue = map[string]Color{",
  (string) (len=48) "\t_ColorName[0:5]:                    ColorBlack,",
  (string) (len=48) "\tstrings.ToLower(_ColorName[0:5]):   ColorBlack,",
  (string) (len=48) "\t_ColorName[5:10]:                   ColorWhite,",
  (string) (len=48) "\tstrings.ToLower(_ColorName[5:10]):  ColorWhite,",
  (string) (len=46) "\t_ColorName[10:13]:                  ColorRed,",
  (string) (len=46) "\tstrings.ToLower(_ColorName[10:13]): ColorRed,",
  (string) (len=48) "\t_ColorName[13:18]:                  ColorGreen,",
  (string) (len=48) "\tstrings.ToLower(_ColorName[13:18]): ColorGreen,",
  (string) (len=47) "\t_ColorName[18:22]:                  ColorBlue,",
  (string) (len=47) "\tstrings.ToLower(_ColorName[18:22]): ColorBlue,",
  (string) (len=47) "\t_ColorName[22:26]:                  ColorGrey,",
  (string) (len=47) "\tstrings.ToLower(_ColorName[22:26]): ColorGrey,",
  (string) (len=49) "\t_ColorName[26:32]:                  ColorYellow,",
  (string) (len=49) "\tstrings.ToLower(_ColorName[26:32]): ColorYellow,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=54) "// ParseColor attempts to convert a string to a Color.",
  (string) (len=45) "func ParseColor(name string) (Color, error) {",
  (string) (len=36) "\tif x, ok := _ColorValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=53) "\tif x, ok := _ColorValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=63) "\treturn Color(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidColor)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=75) "// MustParseColor converts a string to a Color, and panics if is not valid.",
  (string) (len=40) "func MustParseColor(name string) Color {",
  (string) (len=29) "\tval, err := ParseColor(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=46) "func (x Color) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=50) "func (x *Color) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=29) "\ttmp, err := ParseColor(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=91) "var errColorNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=53) "func (x *Color) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=15) "\t\t*x = Color(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=15) "\t\t*x = Color(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=25) "\t\t*x, err = ParseColor(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=33) "\t\t*x, err = ParseColor(string(v))",
  (string) (len=12) "\tcase Color:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=15) "\t\t*x = Color(v)",
  (string) (len=13) "\tcase *Color:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errColorNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=15) "\t\t*x = Color(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=15) "\t\t*x = Color(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errColorNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Color(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errColorNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Color(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\t*x = Color(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errColorNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Color(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errColorNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Color(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errColorNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Color(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errColorNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=26) "\t\t*x, err = ParseColor(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=46) "func (x Color) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=31) "func ParseColorExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=62) "\t// ColorWithCommentBlack is a ColorWithComment of type Black.",
  (string) (len=46) "\tColorWithCommentBlack ColorWithComment = iota",
  (string) (len=62) "\t// ColorWithCommentWhite is a ColorWithComment of type White.",
  (string) (len=22) "\tColorWithCommentWhite",
  (string) (len=58) "\t// ColorWithCommentRed is a ColorWithComment of type Red.",
  (string) (len=20) "\tColorWithCommentRed",
  (string) (len=62) "\t// ColorWithCommentGreen is a ColorWithComment of type Green.",
  (string) (len=22) "\tColorWithCommentGreen",
  (string) (len=60) "\t// ColorWithCommentBlue is a ColorWithComment of type Blue.",
  (string) (len=24) "\t// Blue starts with 33.",
  (string) (len=50) "\tColorWithCommentBlue ColorWithComment = iota + 29",
  (string) (len=60) "\t// ColorWithCommentGrey is a ColorWithComment of type Grey.",
  (string) (len=21) "\tColorWithCommentGrey",
  (string) (len=64) "\t// ColorWithCommentYellow is a ColorWithComment of type Yellow.",
  (string) (len=23) "\tColorWithCommentYellow",
  (string) (len=1) ")",
  (string) "",
  (string) (len=129) "var ErrInvalidColorWithComment = fmt.Errorf(\"not a valid ColorWithComment, try [%s]\", strings.Join(_ColorWithCommentNames, \", \"))",
  (string) "",
  (string) (len=64) "const _ColorWithCommentName = \"blackwhiteredgreenbluegreyyellow\"",
  (string) "",
  (string) (len=38) "var _ColorWithCommentNames = []string{",
  (string) (len=28) "\t_ColorWithCommentName[0:5],",
  (string) (len=29) "\t_ColorWithCommentName[5:10],",
  (string) (len=30) "\t_ColorWithCommentName[10:13],",
  (string) (len=30) "\t_ColorWithCommentName[13:18],",
  (string) (len=30) "\t_ColorWithCommentName[18:22],",
  (string) (len=30) "\t_ColorWithCommentName[22:26],",
  (string) (len=30) "\t_ColorWithCommentName[26:32],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=86) "// ColorWithCommentNames returns a list of possible string values of ColorWithComment.",
  (string) (len=39) "func ColorWithCommentNames() []string {",
  (string) (len=51) "\ttmp := make([]string, len(_ColorWithCommentNames))",
  (string) (len=34) "\tcopy(tmp, _ColorWithCommentNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=55) "var _ColorWithCommentMap = map[ColorWithComment]string{",
  (string) (len=52) "\tColorWithCommentBlack:  _ColorWithCommentName[0:5],",
  (string) (len=53) "\tColorWithCommentWhite:  _ColorWithCommentName[5:10],",
  (string) (len=54) "\tColorWithCommentRed:    _ColorWithCommentName[10:13],",
  (string) (len=54) "\tColorWithCommentGreen:  _ColorWithCommentName[13:18],",
  (string) (len=54) "\tColorWithCommentBlue:   _ColorWithCommentName[18:22],",
  (string) (len=54) "\tColorWithCommentGrey:   _ColorWithCommentName[22:26],",
  (string) (len=54) "\tColorWithCommentYellow: _ColorWithCommentName[26:32],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=43) "func (x ColorWithComment) String() string {",
  (string) (len=44) "\tif str, ok := _ColorWithCommentMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=46) "\treturn fmt.Sprintf(\"ColorWithComment(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=42) "func (x ColorWithComment) IsValid() bool {",
  (string) (len=33) "\t_, ok := _ColorWithCommentMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "var _ColorWithCommentValue = map[string]ColorWithComment{",
  (string) (len=70) "\t_ColorWithCommentName[0:5]:                    ColorWithCommentBlack,",
  (string) (len=70) "\tstrings.ToLower(_ColorWithCommentName[0:5]):   ColorWithCommentBlack,",
  (string) (len=70) "\t_ColorWithCommentName[5:10]:                   ColorWithCommentWhite,",
  (string) (len=70) "\tstrings.ToLower(_ColorWithCommentName[5:10]):  ColorWithCommentWhite,",
  (string) (len=68) "\t_ColorWithCommentName[10:13]:                  ColorWithCommentRed,",
  (string) (len=68) "\tstrings.ToLower(_ColorWithCommentName[10:13]): ColorWithCommentRed,",
  (string) (len=70) "\t_ColorWithCommentName[13:18]:                  ColorWithCommentGreen,",
  (string) (len=70) "\tstrings.ToLower(_ColorWithCommentName[13:18]): ColorWithCommentGreen,",
  (string) (len=69) "\t_ColorWithCommentName[18:22]:                  ColorWithCommentBlue,",
  (string) (len=69) "\tstrings.ToLower(_ColorWithCommentName[18:22]): ColorWithCommentBlue,",
  (string) (len=69) "\t_ColorWithCommentName[22:26]:                  ColorWithCommentGrey,",
  (string) (len=69) "\tstrings.ToLower(_ColorWithCommentName[22:26]): ColorWithCommentGrey,",
  (string) (len=71) "\t_ColorWithCommentName[26:32]:                  ColorWithCommentYellow,",
  (string) (len=71) "\tstrings.ToLower(_ColorWithCommentName[26:32]): ColorWithCommentYellow,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=76) "// ParseColorWithComment attempts to convert a string to a ColorWithComment.",
  (string) (len=67) "func ParseColorWithComment(name string) (ColorWithComment, error) {",
  (string) (len=47) "\tif x, ok := _ColorWithCommentValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=64) "\tif x, ok := _ColorWithCommentValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=85) "\treturn ColorWithComment(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidColorWithComment)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=97) "// MustParseColorWithComment converts a string to a ColorWithComment, and panics if is not valid.",
  (string) (len=62) "func MustParseColorWithComment(name string) ColorWithComment {",
  (string) (len=40) "\tval, err := ParseColorWithComment(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=57) "func (x ColorWithComment) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=61) "func (x *ColorWithComment) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=40) "\ttmp, err := ParseColorWithComment(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=102) "var errColorWithCommentNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=64) "func (x *ColorWithComment) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=26) "\t\t*x = ColorWithComment(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=26) "\t\t*x = ColorWithComment(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=36) "\t\t*x, err = ParseColorWithComment(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=44) "\t\t*x, err = ParseColorWithComment(string(v))",
  (string) (len=23) "\tcase ColorWithComment:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=26) "\t\t*x = ColorWithComment(v)",
  (string) (len=24) "\tcase *ColorWithComment:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=35) "\t\t\treturn errColorWithCommentNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=26) "\t\t*x = ColorWithComment(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=26) "\t\t*x = ColorWithComment(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=35) "\t\t\treturn errColorWithCommentNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=27) "\t\t*x = ColorWithComment(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=35) "\t\t\treturn errColorWithCommentNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=27) "\t\t*x = ColorWithComment(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=26) "\t\t*x = ColorWithComment(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=35) "\t\t\treturn errColorWithCommentNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=27) "\t\t*x = ColorWithComment(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=35) "\t\t\treturn errColorWithCommentNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=27) "\t\t*x = ColorWithComment(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=35) "\t\t\treturn errColorWithCommentNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=27) "\t\t*x = ColorWithComment(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=35) "\t\t\treturn errColorWithCommentNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=37) "\t\t*x, err = ParseColorWithComment(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=57) "func (x ColorWithComment) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=42) "func ParseColorWithCommentExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=64) "\t// ColorWithComment2Black is a ColorWithComment2 of type Black.",
  (string) (len=48) "\tColorWithComment2Black ColorWithComment2 = iota",
  (string) (len=64) "\t// ColorWithComment2White is a ColorWithComment2 of type White.",
  (string) (len=23) "\tColorWithComment2White",
  (string) (len=60) "\t// ColorWithComment2Red is a ColorWithComment2 of type Red.",
  (string) (len=21) "\tColorWithComment2Red",
  (string) (len=64) "\t// ColorWithComment2Green is a ColorWithComment2 of type Green.",
  (string) (len=23) "\tColorWithComment2Green",
  (string) (len=62) "\t// ColorWithComment2Blue is a ColorWithComment2 of type Blue.",
  (string) (len=23) "\t// Blue starts with 33",
  (string) (len=52) "\tColorWithComment2Blue ColorWithComment2 = iota + 29",
  (string) (len=62) "\t// ColorWithComment2Grey is a ColorWithComment2 of type Grey.",
  (string) (len=22) "\tColorWithComment2Grey",
  (string) (len=66) "\t// ColorWithComment2Yellow is a ColorWithComment2 of type Yellow.",
  (string) (len=24) "\tColorWithComment2Yellow",
  (string) (len=1) ")",
  (string) "",
  (string) (len=132) "var ErrInvalidColorWithComment2 = fmt.Errorf(\"not a valid ColorWithComment2, try [%s]\", strings.Join(_ColorWithComment2Names, \", \"))",
  (string) "",
  (string) (len=65) "const _ColorWithComment2Name = \"blackwhiteredgreenbluegreyyellow\"",
  (string) "",
  (string) (len=39) "var _ColorWithComment2Names = []string{",
  (string) (len=29) "\t_ColorWithComment2Name[0:5],",
  (string) (len=30) "\t_ColorWithComment2Name[5:10],",
  (string) (len=31) "\t_ColorWithComment2Name[10:13],",
  (string) (len=31) "\t_ColorWithComment2Name[13:18],",
  (string) (len=31) "\t_ColorWithComment2Name[18:22],",
  (string) (len=31) "\t_ColorWithComment2Name[22:26],",
  (string) (len=31) "\t_ColorWithComment2Name[26:32],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=88) "// ColorWithComment2Names returns a list of possible string values of ColorWithComment2.",
  (string) (len=40) "func ColorWithComment2Names() []string {",
  (string) (len=52) "\ttmp := make([]string, len(_ColorWithComment2Names))",
  (string) (len=35) "\tcopy(tmp, _ColorWithComment2Names)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "var _ColorWithComment2Map = map[ColorWithComment2]string{",
  (string) (len=54) "\tColorWithComment2Black:  _ColorWithComment2Name[0:5],",
  (string) (len=55) "\tColorWithComment2White:  _ColorWithComment2Name[5:10],",
  (string) (len=56) "\tColorWithComment2Red:    _ColorWithComment2Name[10:13],",
  (string) (len=56) "\tColorWithComment2Green:  _ColorWithComment2Name[13:18],",
  (string) (len=56) "\tColorWithComment2Blue:   _ColorWithComment2Name[18:22],",
  (string) (len=56) "\tColorWithComment2Grey:   _ColorWithComment2Name[22:26],",
  (string) (len=56) "\tColorWithComment2Yellow: _ColorWithComment2Name[26:32],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=44) "func (x ColorWithComment2) String() string {",
  (string) (len=45) "\tif str, ok := _ColorWithComment2Map[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=47) "\treturn fmt.Sprintf(\"ColorWithComment2(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=43) "func (x ColorWithComment2) IsValid() bool {",
  (string) (len=34) "\t_, ok := _ColorWithComment2Map[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=59) "var _ColorWithComment2Value = map[string]ColorWithComment2{",
  (string) (len=72) "\t_ColorWithComment2Name[0:5]:                    ColorWithComment2Black,",
  (string) (len=72) "\tstrings.ToLower(_ColorWithComment2Name[0:5]):   ColorWithComment2Black,",
  (string) (len=72) "\t_ColorWithComment2Name[5:10]:                   ColorWithComment2White,",
  (string) (len=72) "\tstrings.ToLower(_ColorWithComment2Name[5:10]):  ColorWithComment2White,",
  (string) (len=70) "\t_ColorWithComment2Name[10:13]:                  ColorWithComment2Red,",
  (string) (len=70) "\tstrings.ToLower(_ColorWithComment2Name[10:13]): ColorWithComment2Red,",
  (string) (len=72) "\t_ColorWithComment2Name[13:18]:                  ColorWithComment2Green,",
  (string) (len=72) "\tstrings.ToLower(_ColorWithComment2Name[13:18]): ColorWithComment2Green,",
  (string) (len=71) "\t_ColorWithComment2Name[18:22]:                  ColorWithComment2Blue,",
  (string) (len=71) "\tstrings.ToLower(_ColorWithComment2Name[18:22]): ColorWithComment2Blue,",
  (string) (len=71) "\t_ColorWithComment2Name[22:26]:                  ColorWithComment2Grey,",
  (string) (len=71) "\tstrings.ToLower(_ColorWithComment2Name[22:26]): ColorWithComment2Grey,",
  (string) (len=73) "\t_ColorWithComment2Name[26:32]:                  ColorWithComment2Yellow,",
  (string) (len=73) "\tstrings.ToLower(_ColorWithComment2Name[26:32]): ColorWithComment2Yellow,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=78) "// ParseColorWithComment2 attempts to convert a string to a ColorWithComment2.",
  (string) (len=69) "func ParseColorWithComment2(name string) (ColorWithComment2, error) {",
  (string) (len=48) "\tif x, ok := _ColorWithComment2Value[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=65) "\tif x, ok := _ColorWithComment2Value[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=87) "\treturn ColorWithComment2(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidColorWithComment2)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=99) "// MustParseColorWithComment2 converts a string to a ColorWithComment2, and panics if is not valid.",
  (string) (len=64) "func MustParseColorWithComment2(name string) ColorWithComment2 {",
  (string) (len=41) "\tval, err := ParseColorWithComment2(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=58) "func (x ColorWithComment2) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=62) "func (x *ColorWithComment2) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=41) "\ttmp, err := ParseColorWithComment2(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=103) "var errColorWithComment2NilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=65) "func (x *ColorWithComment2) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=27) "\t\t*x = ColorWithComment2(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=27) "\t\t*x = ColorWithComment2(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=37) "\t\t*x, err = ParseColorWithComment2(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=45) "\t\t*x, err = ParseColorWithComment2(string(v))",
  (string) (len=24) "\tcase ColorWithComment2:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=27) "\t\t*x = ColorWithComment2(v)",
  (string) (len=25) "\tcase *ColorWithComment2:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment2NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=27) "\t\t*x = ColorWithComment2(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=27) "\t\t*x = ColorWithComment2(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment2NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment2(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment2NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment2(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=27) "\t\t*x = ColorWithComment2(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment2NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment2(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment2NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment2(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment2NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment2(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment2NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=38) "\t\t*x, err = ParseColorWithComment2(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=58) "func (x ColorWithComment2) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=43) "func ParseColorWithComment2Example() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=64) "\t// ColorWithComment3Black is a ColorWithComment3 of type Black.",
  (string) (len=48) "\tColorWithComment3Black ColorWithComment3 = iota",
  (string) (len=64) "\t// ColorWithComment3White is a ColorWithComment3 of type White.",
  (string) (len=23) "\tColorWithComment3White",
  (string) (len=60) "\t// ColorWithComment3Red is a ColorWithComment3 of type Red.",
  (string) (len=21) "\tColorWithComment3Red",
  (string) (len=64) "\t// ColorWithComment3Green is a ColorWithComment3 of type Green.",
  (string) (len=24) "\t// Green starts with 33",
  (string) (len=53) "\tColorWithComment3Green ColorWithComment3 = iota + 30",
  (string) (len=62) "\t// ColorWithComment3Blue is a ColorWithComment3 of type Blue.",
  (string) (len=22) "\tColorWithComment3Blue",
  (string) (len=62) "\t// ColorWithComment3Grey is a ColorWithComment3 of type Grey.",
  (string) (len=22) "\tColorWithComment3Grey",
  (string) (len=66) "\t// ColorWithComment3Yellow is a ColorWithComment3 of type Yellow.",
  (string) (len=24) "\tColorWithComment3Yellow",
  (string) (len=73) "\t// ColorWithComment3BlueGreen is a ColorWithComment3 of type Blue-Green.",
  (string) (len=22) "\t// blue-green comment",
  (string) (len=27) "\tColorWithComment3BlueGreen",
  (string) (len=73) "\t// ColorWithComment3RedOrange is a ColorWithComment3 of type Red-Orange.",
  (string) (len=27) "\tColorWithComment3RedOrange",
  (string) (len=82) "\t// ColorWithComment3RedOrangeBlue is a ColorWithComment3 of type Red-Orange-Blue.",
  (string) (len=31) "\tColorWithComment3RedOrangeBlue",
  (string) (len=1) ")",
  (string) "",
  (string) (len=132) "var ErrInvalidColorWithComment3 = fmt.Errorf(\"not a valid ColorWithComment3, try [%s]\", strings.Join(_ColorWithComment3Names, \", \"))",
  (string) "",
  (string) (len=100) "const _ColorWithComment3Name = \"blackwhiteredgreenbluegreyyellowblue-greenred-orangered-orange-blue\"",
  (string) "",
  (string) (len=39) "var _ColorWithComment3Names = []string{",
  (string) (len=29) "\t_ColorWithComment3Name[0:5],",
  (string) (len=30) "\t_ColorWithComment3Name[5:10],",
  (string) (len=31) "\t_ColorWithComment3Name[10:13],",
  (string) (len=31) "\t_ColorWithComment3Name[13:18],",
  (string) (len=31) "\t_ColorWithComment3Name[18:22],",
  (string) (len=31) "\t_ColorWithComment3Name[22:26],",
  (string) (len=31) "\t_ColorWithComment3Name[26:32],",
  (string) (len=31) "\t_ColorWithComment3Name[32:42],",
  (string) (len=31) "\t_ColorWithComment3Name[42:52],",
  (string) (len=31) "\t_ColorWithComment3Name[52:67],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=88) "// ColorWithComment3Names returns a list of possible string values of ColorWithComment3.",
  (string) (len=40) "func ColorWithComment3Names() []string {",
  (string) (len=52) "\ttmp := make([]string, len(_ColorWithComment3Names))",
  (string) (len=35) "\tcopy(tmp, _ColorWithComment3Names)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "var _ColorWithComment3Map = map[ColorWithComment3]string{",
  (string) (len=61) "\tColorWithComment3Black:         _ColorWithComment3Name[0:5],",
  (string) (len=62) "\tColorWithComment3White:         _ColorWithComment3Name[5:10],",
  (string) (len=63) "\tColorWithComment3Red:           _ColorWithComment3Name[10:13],",
  (string) (len=63) "\tColorWithComment3Green:         _ColorWithComment3Name[13:18],",
  (string) (len=63) "\tColorWithComment3Blue:          _ColorWithComment3Name[18:22],",
  (string) (len=63) "\tColorWithComment3Grey:          _ColorWithComment3Name[22:26],",
  (string) (len=63) "\tColorWithComment3Yellow:        _ColorWithComment3Name[26:32],",
  (string) (len=63) "\tColorWithComment3BlueGreen:     _ColorWithComment3Name[32:42],",
  (string) (len=63) "\tColorWithComment3RedOrange:     _ColorWithComment3Name[42:52],",
  (string) (len=63) "\tColorWithComment3RedOrangeBlue: _ColorWithComment3Name[52:67],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=44) "func (x ColorWithComment3) String() string {",
  (string) (len=45) "\tif str, ok := _ColorWithComment3Map[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=47) "\treturn fmt.Sprintf(\"ColorWithComment3(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=43) "func (x ColorWithComment3) IsValid() bool {",
  (string) (len=34) "\t_, ok := _ColorWithComment3Map[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=59) "var _ColorWithComment3Value = map[string]ColorWithComment3{",
  (string) (len=72) "\t_ColorWithComment3Name[0:5]:                    ColorWithComment3Black,",
  (string) (len=72) "\tstrings.ToLower(_ColorWithComment3Name[0:5]):   ColorWithComment3Black,",
  (string) (len=72) "\t_ColorWithComment3Name[5:10]:                   ColorWithComment3White,",
  (string) (len=72) "\tstrings.ToLower(_ColorWithComment3Name[5:10]):  ColorWithComment3White,",
  (string) (len=70) "\t_ColorWithComment3Name[10:13]:                  ColorWithComment3Red,",
  (string) (len=70) "\tstrings.ToLower(_ColorWithComment3Name[10:13]): ColorWithComment3Red,",
  (string) (len=72) "\t_ColorWithComment3Name[13:18]:                  ColorWithComment3Green,",
  (string) (len=72) "\tstrings.ToLower(_ColorWithComment3Name[13:18]): ColorWithComment3Green,",
  (string) (len=71) "\t_ColorWithComment3Name[18:22]:                  ColorWithComment3Blue,",
  (string) (len=71) "\tstrings.ToLower(_ColorWithComment3Name[18:22]): ColorWithComment3Blue,",
  (string) (len=71) "\t_ColorWithComment3Name[22:26]:                  ColorWithComment3Grey,",
  (string) (len=71) "\tstrings.ToLower(_ColorWithComment3Name[22:26]): ColorWithComment3Grey,",
  (string) (len=73) "\t_ColorWithComment3Name[26:32]:                  ColorWithComment3Yellow,",
  (string) (len=73) "\tstrings.ToLower(_ColorWithComment3Name[26:32]): ColorWithComment3Yellow,",
  (string) (len=76) "\t_ColorWithComment3Name[32:42]:                  ColorWithComment3BlueGreen,",
  (string) (len=76) "\tstrings.ToLower(_ColorWithComment3Name[32:42]): ColorWithComment3BlueGreen,",
  (string) (len=76) "\t_ColorWithComment3Name[42:52]:                  ColorWithComment3RedOrange,",
  (string) (len=76) "\tstrings.ToLower(_ColorWithComment3Name[42:52]): ColorWithComment3RedOrange,",
  (string) (len=80) "\t_ColorWithComment3Name[52:67]:                  ColorWithComment3RedOrangeBlue,",
  (string) (len=80) "\tstrings.ToLower(_ColorWithComment3Name[52:67]): ColorWithComment3RedOrangeBlue,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=78) "// ParseColorWithComment3 attempts to convert a string to a ColorWithComment3.",
  (string) (len=69) "func ParseColorWithComment3(name string) (ColorWithComment3, error) {",
  (string) (len=48) "\tif x, ok := _ColorWithComment3Value[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=65) "\tif x, ok := _ColorWithComment3Value[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=87) "\treturn ColorWithComment3(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidColorWithComment3)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=99) "// MustParseColorWithComment3 converts a string to a ColorWithComment3, and panics if is not valid.",
  (string) (len=64) "func MustParseColorWithComment3(name string) ColorWithComment3 {",
  (string) (len=41) "\tval, err := ParseColorWithComment3(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=58) "func (x ColorWithComment3) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=62) "func (x *ColorWithComment3) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=41) "\ttmp, err := ParseColorWithComment3(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=103) "var errColorWithComment3NilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=65) "func (x *ColorWithComment3) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=27) "\t\t*x = ColorWithComment3(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=27) "\t\t*x = ColorWithComment3(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=37) "\t\t*x, err = ParseColorWithComment3(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=45) "\t\t*x, err = ParseColorWithComment3(string(v))",
  (string) (len=24) "\tcase ColorWithComment3:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=27) "\t\t*x = ColorWithComment3(v)",
  (string) (len=25) "\tcase *ColorWithComment3:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment3NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=27) "\t\t*x = ColorWithComment3(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=27) "\t\t*x = ColorWithComment3(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment3NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment3(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment3NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment3(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=27) "\t\t*x = ColorWithComment3(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment3NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment3(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment3NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment3(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment3NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment3(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment3NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=38) "\t\t*x, err = ParseColorWithComment3(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=58) "func (x ColorWithComment3) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=43) "func ParseColorWithComment3Example() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=18) "\t// Skipped value.",
  (string) (len=15) "\t// Placeholder",
  (string) (len=27) "\t_ ColorWithComment4 = iota",
  (string) (len=64) "\t// ColorWithComment4Black is a ColorWithComment4 of type Black.",
  (string) (len=23) "\tColorWithComment4Black",
  (string) (len=64) "\t// ColorWithComment4White is a ColorWithComment4 of type White.",
  (string) (len=23) "\tColorWithComment4White",
  (string) (len=60) "\t// ColorWithComment4Red is a ColorWithComment4 of type Red.",
  (string) (len=21) "\tColorWithComment4Red",
  (string) (len=64) "\t// ColorWithComment4Green is a ColorWithComment4 of type Green.",
  (string) (len=24) "\t// Green starts with 33",
  (string) (len=53) "\tColorWithComment4Green ColorWithComment4 = iota + 29",
  (string) (len=62) "\t// ColorWithComment4Blue is a ColorWithComment4 of type Blue.",
  (string) (len=22) "\tColorWithComment4Blue",
  (string) (len=62) "\t// ColorWithComment4Grey is a ColorWithComment4 of type Grey.",
  (string) (len=22) "\tColorWithComment4Grey",
  (string) (len=66) "\t// ColorWithComment4Yellow is a ColorWithComment4 of type Yellow.",
  (string) (len=110) "\t// Where did all the (somewhat) bad fish go? (something else that goes in parentheses at the end of the line)",
  (string) (len=24) "\tColorWithComment4Yellow",
  (string) (len=73) "\t// ColorWithComment4BlueGreen is a ColorWithComment4 of type Blue-Green.",
  (string) (len=22) "\t// blue-green comment",
  (string) (len=27) "\tColorWithComment4BlueGreen",
  (string) (len=73) "\t// ColorWithComment4RedOrange is a ColorWithComment4 of type Red-Orange.",
  (string) (len=20) "\t// has a , in it!?!",
  (string) (len=27) "\tColorWithComment4RedOrange",
  (string) (len=1) ")",
  (string) "",
  (string) (len=132) "var ErrInvalidColorWithComment4 = fmt.Errorf(\"not a valid ColorWithComment4, try [%s]\", strings.Join(_ColorWithComment4Names, \", \"))",
  (string) "",
  (string) (len=85) "const _ColorWithComment4Name = \"blackwhiteredgreenbluegreyyellowblue-greenred-orange\"",
  (string) "",
  (string) (len=39) "var _ColorWithComment4Names = []string{",
  (string) (len=29) "\t_ColorWithComment4Name[0:5],",
  (string) (len=30) "\t_ColorWithComment4Name[5:10],",
  (string) (len=31) "\t_ColorWithComment4Name[10:13],",
  (string) (len=31) "\t_ColorWithComment4Name[13:18],",
  (string) (len=31) "\t_ColorWithComment4Name[18:22],",
  (string) (len=31) "\t_ColorWithComment4Name[22:26],",
  (string) (len=31) "\t_ColorWithComment4Name[26:32],",
  (string) (len=31) "\t_ColorWithComment4Name[32:42],",
  (string) (len=31) "\t_ColorWithComment4Name[42:52],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=88) "// ColorWithComment4Names returns a list of possible string values of ColorWithComment4.",
  (string) (len=40) "func ColorWithComment4Names() []string {",
  (string) (len=52) "\ttmp := make([]string, len(_ColorWithComment4Names))",
  (string) (len=35) "\tcopy(tmp, _ColorWithComment4Names)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "var _ColorWithComment4Map = map[ColorWithComment4]string{",
  (string) (len=57) "\tColorWithComment4Black:     _ColorWithComment4Name[0:5],",
  (string) (len=58) "\tColorWithComment4White:     _ColorWithComment4Name[5:10],",
  (string) (len=59) "\tColorWithComment4Red:       _ColorWithComment4Name[10:13],",
  (string) (len=59) "\tColorWithComment4Green:     _ColorWithComment4Name[13:18],",
  (string) (len=59) "\tColorWithComment4Blue:      _ColorWithComment4Name[18:22],",
  (string) (len=59) "\tColorWithComment4Grey:      _ColorWithComment4Name[22:26],",
  (string) (len=59) "\tColorWithComment4Yellow:    _ColorWithComment4Name[26:32],",
  (string) (len=59) "\tColorWithComment4BlueGreen: _ColorWithComment4Name[32:42],",
  (string) (len=59) "\tColorWithComment4RedOrange: _ColorWithComment4Name[42:52],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=44) "func (x ColorWithComment4) String() string {",
  (string) (len=45) "\tif str, ok := _ColorWithComment4Map[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=47) "\treturn fmt.Sprintf(\"ColorWithComment4(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=43) "func (x ColorWithComment4) IsValid() bool {",
  (string) (len=34) "\t_, ok := _ColorWithComment4Map[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=59) "var _ColorWithComment4Value = map[string]ColorWithComment4{",
  (string) (len=72) "\t_ColorWithComment4Name[0:5]:                    ColorWithComment4Black,",
  (string) (len=72) "\tstrings.ToLower(_ColorWithComment4Name[0:5]):   ColorWithComment4Black,",
  (string) (len=72) "\t_ColorWithComment4Name[5:10]:                   ColorWithComment4White,",
  (string) (len=72) "\tstrings.ToLower(_ColorWithComment4Name[5:10]):  ColorWithComment4White,",
  (string) (len=70) "\t_ColorWithComment4Name[10:13]:                  ColorWithComment4Red,",
  (string) (len=70) "\tstrings.ToLower(_ColorWithComment4Name[10:13]): ColorWithComment4Red,",
  (string) (len=72) "\t_ColorWithComment4Name[13:18]:                  ColorWithComment4Green,",
  (string) (len=72) "\tstrings.ToLower(_ColorWithComment4Name[13:18]): ColorWithComment4Green,",
  (string) (len=71) "\t_ColorWithComment4Name[18:22]:                  ColorWithComment4Blue,",
  (string) (len=71) "\tstrings.ToLower(_ColorWithComment4Name[18:22]): ColorWithComment4Blue,",
  (string) (len=71) "\t_ColorWithComment4Name[22:26]:                  ColorWithComment4Grey,",
  (string) (len=71) "\tstrings.ToLower(_ColorWithComment4Name[22:26]): ColorWithComment4Grey,",
  (string) (len=73) "\t_ColorWithComment4Name[26:32]:                  ColorWithComment4Yellow,",
  (string) (len=73) "\tstrings.ToLower(_ColorWithComment4Name[26:32]): ColorWithComment4Yellow,",
  (string) (len=76) "\t_ColorWithComment4Name[32:42]:                  ColorWithComment4BlueGreen,",
  (string) (len=76) "\tstrings.ToLower(_ColorWithComment4Name[32:42]): ColorWithComment4BlueGreen,",
  (string) (len=76) "\t_ColorWithComment4Name[42:52]:                  ColorWithComment4RedOrange,",
  (string) (len=76) "\tstrings.ToLower(_ColorWithComment4Name[42:52]): ColorWithComment4RedOrange,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=78) "// ParseColorWithComment4 attempts to convert a string to a ColorWithComment4.",
  (string) (len=69) "func ParseColorWithComment4(name string) (ColorWithComment4, error) {",
  (string) (len=48) "\tif x, ok := _ColorWithComment4Value[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=65) "\tif x, ok := _ColorWithComment4Value[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=87) "\treturn ColorWithComment4(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidColorWithComment4)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=99) "// MustParseColorWithComment4 converts a string to a ColorWithComment4, and panics if is not valid.",
  (string) (len=64) "func MustParseColorWithComment4(name string) ColorWithComment4 {",
  (string) (len=41) "\tval, err := ParseColorWithComment4(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=58) "func (x ColorWithComment4) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=62) "func (x *ColorWithComment4) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=41) "\ttmp, err := ParseColorWithComment4(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=103) "var errColorWithComment4NilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=65) "func (x *ColorWithComment4) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=27) "\t\t*x = ColorWithComment4(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=27) "\t\t*x = ColorWithComment4(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=37) "\t\t*x, err = ParseColorWithComment4(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=45) "\t\t*x, err = ParseColorWithComment4(string(v))",
  (string) (len=24) "\tcase ColorWithComment4:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=27) "\t\t*x = ColorWithComment4(v)",
  (string) (len=25) "\tcase *ColorWithComment4:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment4NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=27) "\t\t*x = ColorWithComment4(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=27) "\t\t*x = ColorWithComment4(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment4NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment4(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment4NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment4(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=27) "\t\t*x = ColorWithComment4(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment4NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment4(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment4NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment4(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment4NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=28) "\t\t*x = ColorWithComment4(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=36) "\t\t\treturn errColorWithComment4NilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=38) "\t\t*x, err = ParseColorWithComment4(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=58) "func (x ColorWithComment4) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=43) "func ParseColorWithComment4Example() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=52) "\t// Enum64bitUnknown is a Enum64bit of type Unknown.",
  (string) (len=34) "\tEnum64bitUnknown Enum64bit = iota",
  (string) (len=48) "\t// Enum64bitE2P15 is a Enum64bit of type E2P15.",
  (string) (len=40) "\tEnum64bitE2P15 Enum64bit = iota + 32767",
  (string) (len=48) "\t// Enum64bitE2P16 is a Enum64bit of type E2P16.",
  (string) (len=40) "\tEnum64bitE2P16 Enum64bit = iota + 65534",
  (string) (len=48) "\t// Enum64bitE2P17 is a Enum64bit of type E2P17.",
  (string) (len=41) "\tEnum64bitE2P17 Enum64bit = iota + 131069",
  (string) (len=48) "\t// Enum64bitE2P18 is a Enum64bit of type E2P18.",
  (string) (len=41) "\tEnum64bitE2P18 Enum64bit = iota + 262140",
  (string) (len=48) "\t// Enum64bitE2P19 is a Enum64bit of type E2P19.",
  (string) (len=41) "\tEnum64bitE2P19 Enum64bit = iota + 524283",
  (string) (len=48) "\t// Enum64bitE2P20 is a Enum64bit of type E2P20.",
  (string) (len=42) "\tEnum64bitE2P20 Enum64bit = iota + 1048570",
  (string) (len=48) "\t// Enum64bitE2P21 is a Enum64bit of type E2P21.",
  (string) (len=42) "\tEnum64bitE2P21 Enum64bit = iota + 2097145",
  (string) (len=48) "\t// Enum64bitE2P22 is a Enum64bit of type E2P22.",
  (string) (len=43) "\tEnum64bitE2P22 Enum64bit = iota + 33554424",
  (string) (len=48) "\t// Enum64bitE2P23 is a Enum64bit of type E2P23.",
  (string) (len=43) "\tEnum64bitE2P23 Enum64bit = iota + 67108855",
  (string) (len=48) "\t// Enum64bitE2P28 is a Enum64bit of type E2P28.",
  (string) (len=44) "\tEnum64bitE2P28 Enum64bit = iota + 536870902",
  (string) (len=48) "\t// Enum64bitE2P30 is a Enum64bit of type E2P30.",
  (string) (len=45) "\tEnum64bitE2P30 Enum64bit = iota + 1073741813",
  (string) (len=48) "\t// Enum64bitE2P31 is a Enum64bit of type E2P31.",
  (string) (len=45) "\tEnum64bitE2P31 Enum64bit = iota + 2147483636",
  (string) (len=48) "\t// Enum64bitE2P32 is a Enum64bit of type E2P32.",
  (string) (len=45) "\tEnum64bitE2P32 Enum64bit = iota + 4294967283",
  (string) (len=48) "\t// Enum64bitE2P33 is a Enum64bit of type E2P33.",
  (string) (len=45) "\tEnum64bitE2P33 Enum64bit = iota + 8454967282",
  (string) (len=1) ")",
  (string) "",
  (string) (len=108) "var ErrInvalidEnum64bit = fmt.Errorf(\"not a valid Enum64bit, try [%s]\", strings.Join(_Enum64bitNames, \", \"))",
  (string) "",
  (string) (len=102) "const _Enum64bitName = \"unknowne2p15e2p16e2p17e2p18e2p19e2p20e2p21e2p22e2p23e2p28e2p30e2p31e2p32e2p33\"",
  (string) "",
  (string) (len=31) "var _Enum64bitNames = []string{",
  (string) (len=21) "\t_Enum64bitName[0:7],",
  (string) (len=22) "\t_Enum64bitName[7:12],",
  (string) (len=23) "\t_Enum64bitName[12:17],",
  (string) (len=23) "\t_Enum64bitName[17:22],",
  (string) (len=23) "\t_Enum64bitName[22:27],",
  (string) (len=23) "\t_Enum64bitName[27:32],",
  (string) (len=23) "\t_Enum64bitName[32:37],",
  (string) (len=23) "\t_Enum64bitName[37:42],",
  (string) (len=23) "\t_Enum64bitName[42:47],",
  (string) (len=23) "\t_Enum64bitName[47:52],",
  (string) (len=23) "\t_Enum64bitName[52:57],",
  (string) (len=23) "\t_Enum64bitName[57:62],",
  (string) (len=23) "\t_Enum64bitName[62:67],",
  (string) (len=23) "\t_Enum64bitName[67:72],",
  (string) (len=23) "\t_Enum64bitName[72:77],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=72) "// Enum64bitNames returns a list of possible string values of Enum64bit.",
  (string) (len=32) "func Enum64bitNames() []string {",
  (string) (len=44) "\ttmp := make([]string, len(_Enum64bitNames))",
  (string) (len=27) "\tcopy(tmp, _Enum64bitNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=41) "var _Enum64bitMap = map[Enum64bit]string{",
  (string) (len=39) "\tEnum64bitUnknown: _Enum64bitName[0:7],",
  (string) (len=40) "\tEnum64bitE2P15:   _Enum64bitName[7:12],",
  (string) (len=41) "\tEnum64bitE2P16:   _Enum64bitName[12:17],",
  (string) (len=41) "\tEnum64bitE2P17:   _Enum64bitName[17:22],",
  (string) (len=41) "\tEnum64bitE2P18:   _Enum64bitName[22:27],",
  (string) (len=41) "\tEnum64bitE2P19:   _Enum64bitName[27:32],",
  (string) (len=41) "\tEnum64bitE2P20:   _Enum64bitName[32:37],",
  (string) (len=41) "\tEnum64bitE2P21:   _Enum64bitName[37:42],",
  (string) (len=41) "\tEnum64bitE2P22:   _Enum64bitName[42:47],",
  (string) (len=41) "\tEnum64bitE2P23:   _Enum64bitName[47:52],",
  (string) (len=41) "\tEnum64bitE2P28:   _Enum64bitName[52:57],",
  (string) (len=41) "\tEnum64bitE2P30:   _Enum64bitName[57:62],",
  (string) (len=41) "\tEnum64bitE2P31:   _Enum64bitName[62:67],",
  (string) (len=41) "\tEnum64bitE2P32:   _Enum64bitName[67:72],",
  (string) (len=41) "\tEnum64bitE2P33:   _Enum64bitName[72:77],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=36) "func (x Enum64bit) String() string {",
  (string) (len=37) "\tif str, ok := _Enum64bitMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=39) "\treturn fmt.Sprintf(\"Enum64bit(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=35) "func (x Enum64bit) IsValid() bool {",
  (string) (len=26) "\t_, ok := _Enum64bitMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=43) "var _Enum64bitValue = map[string]Enum64bit{",
  (string) (len=58) "\t_Enum64bitName[0:7]:                    Enum64bitUnknown,",
  (string) (len=58) "\tstrings.ToLower(_Enum64bitName[0:7]):   Enum64bitUnknown,",
  (string) (len=56) "\t_Enum64bitName[7:12]:                   Enum64bitE2P15,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[7:12]):  Enum64bitE2P15,",
  (string) (len=56) "\t_Enum64bitName[12:17]:                  Enum64bitE2P16,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[12:17]): Enum64bitE2P16,",
  (string) (len=56) "\t_Enum64bitName[17:22]:                  Enum64bitE2P17,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[17:22]): Enum64bitE2P17,",
  (string) (len=56) "\t_Enum64bitName[22:27]:                  Enum64bitE2P18,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[22:27]): Enum64bitE2P18,",
  (string) (len=56) "\t_Enum64bitName[27:32]:                  Enum64bitE2P19,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[27:32]): Enum64bitE2P19,",
  (string) (len=56) "\t_Enum64bitName[32:37]:                  Enum64bitE2P20,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[32:37]): Enum64bitE2P20,",
  (string) (len=56) "\t_Enum64bitName[37:42]:                  Enum64bitE2P21,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[37:42]): Enum64bitE2P21,",
  (string) (len=56) "\t_Enum64bitName[42:47]:                  Enum64bitE2P22,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[42:47]): Enum64bitE2P22,",
  (string) (len=56) "\t_Enum64bitName[47:52]:                  Enum64bitE2P23,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[47:52]): Enum64bitE2P23,",
  (string) (len=56) "\t_Enum64bitName[52:57]:                  Enum64bitE2P28,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[52:57]): Enum64bitE2P28,",
  (string) (len=56) "\t_Enum64bitName[57:62]:                  Enum64bitE2P30,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[57:62]): Enum64bitE2P30,",
  (string) (len=56) "\t_Enum64bitName[62:67]:                  Enum64bitE2P31,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[62:67]): Enum64bitE2P31,",
  (string) (len=56) "\t_Enum64bitName[67:72]:                  Enum64bitE2P32,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[67:72]): Enum64bitE2P32,",
  (string) (len=56) "\t_Enum64bitName[72:77]:                  Enum64bitE2P33,",
  (string) (len=56) "\tstrings.ToLower(_Enum64bitName[72:77]): Enum64bitE2P33,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=62) "// ParseEnum64bit attempts to convert a string to a Enum64bit.",
  (string) (len=53) "func ParseEnum64bit(name string) (Enum64bit, error) {",
  (string) (len=40) "\tif x, ok := _Enum64bitValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=57) "\tif x, ok := _Enum64bitValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=71) "\treturn Enum64bit(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidEnum64bit)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=83) "// MustParseEnum64bit converts a string to a Enum64bit, and panics if is not valid.",
  (string) (len=48) "func MustParseEnum64bit(name string) Enum64bit {",
  (string) (len=33) "\tval, err := ParseEnum64bit(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=50) "func (x Enum64bit) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=54) "func (x *Enum64bit) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=33) "\ttmp, err := ParseEnum64bit(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=95) "var errEnum64bitNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=57) "func (x *Enum64bit) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=19) "\t\t*x = Enum64bit(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=19) "\t\t*x = Enum64bit(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=29) "\t\t*x, err = ParseEnum64bit(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=37) "\t\t*x, err = ParseEnum64bit(string(v))",
  (string) (len=16) "\tcase Enum64bit:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=19) "\t\t*x = Enum64bit(v)",
  (string) (len=17) "\tcase *Enum64bit:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=28) "\t\t\treturn errEnum64bitNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=19) "\t\t*x = Enum64bit(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=19) "\t\t*x = Enum64bit(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=28) "\t\t\treturn errEnum64bitNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=20) "\t\t*x = Enum64bit(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=28) "\t\t\treturn errEnum64bitNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=20) "\t\t*x = Enum64bit(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=19) "\t\t*x = Enum64bit(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=28) "\t\t\treturn errEnum64bitNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=20) "\t\t*x = Enum64bit(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=28) "\t\t\treturn errEnum64bitNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=20) "\t\t*x = Enum64bit(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=28) "\t\t\treturn errEnum64bitNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=20) "\t\t*x = Enum64bit(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=28) "\t\t\treturn errEnum64bitNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=30) "\t\t*x, err = ParseEnum64bit(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=50) "func (x Enum64bit) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=35) "func ParseEnum64bitExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=42) "\t// ModelToyota is a Model of type Toyota.",
  (string) (len=25) "\tModelToyota Model = iota",
  (string) (len=18) "\t// Skipped value.",
  (string) (len=2) "\t_",
  (string) (len=40) "\t// ModelChevy is a Model of type Chevy.",
  (string) (len=11) "\tModelChevy",
  (string) (len=18) "\t// Skipped value.",
  (string) (len=2) "\t_",
  (string) (len=38) "\t// ModelFord is a Model of type Ford.",
  (string) (len=10) "\tModelFord",
  (string) (len=1) ")",
  (string) "",
  (string) (len=96) "var ErrInvalidModel = fmt.Errorf(\"not a valid Model, try [%s]\", strings.Join(_ModelNames, \", \"))",
  (string) "",
  (string) (len=36) "const _ModelName = \"toyotachevyford\"",
  (string) "",
  (string) (len=27) "var _ModelNames = []string{",
  (string) (len=17) "\t_ModelName[0:6],",
  (string) (len=18) "\t_ModelName[6:11],",
  (string) (len=19) "\t_ModelName[11:15],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=64) "// ModelNames returns a list of possible string values of Model.",
  (string) (len=28) "func ModelNames() []string {",
  (string) (len=40) "\ttmp := make([]string, len(_ModelNames))",
  (string) (len=23) "\tcopy(tmp, _ModelNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=33) "var _ModelMap = map[Model]string{",
  (string) (len=30) "\tModelToyota: _ModelName[0:6],",
  (string) (len=31) "\tModelChevy:  _ModelName[6:11],",
  (string) (len=32) "\tModelFord:   _ModelName[11:15],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=32) "func (x Model) String() string {",
  (string) (len=33) "\tif str, ok := _ModelMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=35) "\treturn fmt.Sprintf(\"Model(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=31) "func (x Model) IsValid() bool {",
  (string) (len=22) "\t_, ok := _ModelMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=35) "var _ModelValue = map[string]Model{",
  (string) (len=49) "\t_ModelName[0:6]:                    ModelToyota,",
  (string) (len=49) "\tstrings.ToLower(_ModelName[0:6]):   ModelToyota,",
  (string) (len=48) "\t_ModelName[6:11]:                   ModelChevy,",
  (string) (len=48) "\tstrings.ToLower(_ModelName[6:11]):  ModelChevy,",
  (string) (len=47) "\t_ModelName[11:15]:                  ModelFord,",
  (string) (len=47) "\tstrings.ToLower(_ModelName[11:15]): ModelFord,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=54) "// ParseModel attempts to convert a string to a Model.",
  (string) (len=45) "func ParseModel(name string) (Model, error) {",
  (string) (len=36) "\tif x, ok := _ModelValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=53) "\tif x, ok := _ModelValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=63) "\treturn Model(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidModel)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=75) "// MustParseModel converts a string to a Model, and panics if is not valid.",
  (string) (len=40) "func MustParseModel(name string) Model {",
  (string) (len=29) "\tval, err := ParseModel(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=46) "func (x Model) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=50) "func (x *Model) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=29) "\ttmp, err := ParseModel(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=91) "var errModelNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=53) "func (x *Model) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=15) "\t\t*x = Model(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=15) "\t\t*x = Model(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=25) "\t\t*x, err = ParseModel(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=33) "\t\t*x, err = ParseModel(string(v))",
  (string) (len=12) "\tcase Model:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=15) "\t\t*x = Model(v)",
  (string) (len=13) "\tcase *Model:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errModelNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=15) "\t\t*x = Model(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=15) "\t\t*x = Model(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errModelNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Model(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errModelNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Model(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\t*x = Model(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errModelNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Model(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errModelNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Model(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errModelNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=16) "\t\t*x = Model(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=24) "\t\t\treturn errModelNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=26) "\t\t*x, err = ParseModel(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=46) "func (x Model) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=31) "func ParseModelExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=60) "\t// NonASCIIПродам is a NonASCII of type Продам.",
  (string) (len=44) "\tNonASCIIПродам NonASCII = iota + 1114",
  (string) (len=48) "\t// NonASCII車庫 is a NonASCII of type 車庫.",
  (string) (len=37) "\tNonASCII車庫 NonASCII = iota + 299",
  (string) (len=52) "\t// NonASCIIԷժան is a NonASCII of type Էժան.",
  (string) (len=38) "\tNonASCIIԷժան NonASCII = iota + -1",
  (string) (len=1) ")",
  (string) "",
  (string) (len=105) "var ErrInvalidNonASCII = fmt.Errorf(\"not a valid NonASCII, try [%s]\", strings.Join(_NonASCIINames, \", \"))",
  (string) "",
  (string) (len=50) "const _NonASCIIName = \"продам車庫էժան\"",
  (string) "",
  (string) (len=30) "var _NonASCIINames = []string{",
  (string) (len=21) "\t_NonASCIIName[0:12],",
  (string) (len=22) "\t_NonASCIIName[12:18],",
  (string) (len=22) "\t_NonASCIIName[18:26],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=70) "// NonASCIINames returns a list of possible string values of NonASCII.",
  (string) (len=31) "func NonASCIINames() []string {",
  (string) (len=43) "\ttmp := make([]string, len(_NonASCIINames))",
  (string) (len=26) "\tcopy(tmp, _NonASCIINames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=39) "var _NonASCIIMap = map[NonASCII]string{",
  (string) (len=43) "\tNonASCIIПродам: _NonASCIIName[0:12],",
  (string) (len=42) "\tNonASCII車庫:     _NonASCIIName[12:18],",
  (string) (len=42) "\tNonASCIIԷժան:   _NonASCIIName[18:26],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=35) "func (x NonASCII) String() string {",
  (string) (len=36) "\tif str, ok := _NonASCIIMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=38) "\treturn fmt.Sprintf(\"NonASCII(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=34) "func (x NonASCII) IsValid() bool {",
  (string) (len=25) "\t_, ok := _NonASCIIMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=41) "var _NonASCIIValue = map[string]NonASCII{",
  (string) (len=61) "\t_NonASCIIName[0:12]:                   NonASCIIПродам,",
  (string) (len=61) "\tstrings.ToLower(_NonASCIIName[0:12]):  NonASCIIПродам,",
  (string) (len=55) "\t_NonASCIIName[12:18]:                  NonASCII車庫,",
  (string) (len=55) "\tstrings.ToLower(_NonASCIIName[12:18]): NonASCII車庫,",
  (string) (len=57) "\t_NonASCIIName[18:26]:                  NonASCIIԷժան,",
  (string) (len=57) "\tstrings.ToLower(_NonASCIIName[18:26]): NonASCIIԷժան,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=60) "// ParseNonASCII attempts to convert a string to a NonASCII.",
  (string) (len=51) "func ParseNonASCII(name string) (NonASCII, error) {",
  (string) (len=39) "\tif x, ok := _NonASCIIValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=56) "\tif x, ok := _NonASCIIValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=69) "\treturn NonASCII(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidNonASCII)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=81) "// MustParseNonASCII converts a string to a NonASCII, and panics if is not valid.",
  (string) (len=46) "func MustParseNonASCII(name string) NonASCII {",
  (string) (len=32) "\tval, err := ParseNonASCII(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=49) "func (x NonASCII) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=53) "func (x *NonASCII) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=32) "\ttmp, err := ParseNonASCII(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=94) "var errNonASCIINilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=56) "func (x *NonASCII) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=18) "\t\t*x = NonASCII(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=18) "\t\t*x = NonASCII(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=28) "\t\t*x, err = ParseNonASCII(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=36) "\t\t*x, err = ParseNonASCII(string(v))",
  (string) (len=15) "\tcase NonASCII:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=18) "\t\t*x = NonASCII(v)",
  (string) (len=16) "\tcase *NonASCII:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=27) "\t\t\treturn errNonASCIINilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=18) "\t\t*x = NonASCII(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=18) "\t\t*x = NonASCII(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=27) "\t\t\treturn errNonASCIINilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=19) "\t\t*x = NonASCII(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=27) "\t\t\treturn errNonASCIINilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=19) "\t\t*x = NonASCII(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=18) "\t\t*x = NonASCII(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=27) "\t\t\treturn errNonASCIINilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=19) "\t\t*x = NonASCII(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=27) "\t\t\treturn errNonASCIINilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=19) "\t\t*x = NonASCII(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=27) "\t\t\treturn errNonASCIINilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=19) "\t\t*x = NonASCII(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=27) "\t\t\treturn errNonASCIINilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=29) "\t\t*x, err = ParseNonASCII(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=49) "func (x NonASCII) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=34) "func ParseNonASCIIExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=61) "\t// SanitizingTestHyphen is a Sanitizing of type Test-Hyphen.",
  (string) (len=39) "\tSanitizingTestHyphen Sanitizing = iota",
  (string) (len=63) "\t// SanitizingHyphenStart is a Sanitizing of type -HyphenStart.",
  (string) (len=22) "\tSanitizingHyphenStart",
  (string) (len=72) "\t// Sanitizing_UnderscoreFirst is a Sanitizing of type _UnderscoreFirst.",
  (string) (len=27) "\tSanitizing_UnderscoreFirst",
  (string) (len=64) "\t// Sanitizing0NumberFirst is a Sanitizing of type 0NumberFirst.",
  (string) (len=23) "\tSanitizing0NumberFirst",
  (string) (len=60) "\t// Sanitizing123456789A is a Sanitizing of type 123456789A.",
  (string) (len=21) "\tSanitizing123456789A",
  (string) (len=61) "\t// Sanitizing123123Asdf is a Sanitizing of type 123123-Asdf.",
  (string) (len=21) "\tSanitizing123123Asdf",
  (string) (len=66) "\t// SanitizingEndingHyphen is a Sanitizing of type Ending-Hyphen-.",
  (string) (len=23) "\tSanitizingEndingHyphen",
  (string) (len=1) ")",
  (string) "",
  (string) (len=111) "var ErrInvalidSanitizing = fmt.Errorf(\"not a valid Sanitizing, try [%s]\", strings.Join(_SanitizingNames, \", \"))",
  (string) "",
  (string) (len=112) "const _SanitizingName = \"test-hyphen-hyphenstart_underscorefirst0numberfirst123456789a123123-asdfending-hyphen-\"",
  (string) "",
  (string) (len=32) "var _SanitizingNames = []string{",
  (string) (len=23) "\t_SanitizingName[0:11],",
  (string) (len=24) "\t_SanitizingName[11:23],",
  (string) (len=24) "\t_SanitizingName[23:39],",
  (string) (len=24) "\t_SanitizingName[39:51],",
  (string) (len=24) "\t_SanitizingName[51:61],",
  (string) (len=24) "\t_SanitizingName[61:72],",
  (string) (len=24) "\t_SanitizingName[72:86],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=74) "// SanitizingNames returns a list of possible string values of Sanitizing.",
  (string) (len=33) "func SanitizingNames() []string {",
  (string) (len=45) "\ttmp := make([]string, len(_SanitizingNames))",
  (string) (len=28) "\tcopy(tmp, _SanitizingNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=43) "var _SanitizingMap = map[Sanitizing]string{",
  (string) (len=51) "\tSanitizingTestHyphen:       _SanitizingName[0:11],",
  (string) (len=52) "\tSanitizingHyphenStart:      _SanitizingName[11:23],",
  (string) (len=52) "\tSanitizing_UnderscoreFirst: _SanitizingName[23:39],",
  (string) (len=52) "\tSanitizing0NumberFirst:     _SanitizingName[39:51],",
  (string) (len=52) "\tSanitizing123456789A:       _SanitizingName[51:61],",
  (string) (len=52) "\tSanitizing123123Asdf:       _SanitizingName[61:72],",
  (string) (len=52) "\tSanitizingEndingHyphen:     _SanitizingName[72:86],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=37) "func (x Sanitizing) String() string {",
  (string) (len=38) "\tif str, ok := _SanitizingMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=40) "\treturn fmt.Sprintf(\"Sanitizing(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=36) "func (x Sanitizing) IsValid() bool {",
  (string) (len=27) "\t_, ok := _SanitizingMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=45) "var _SanitizingValue = map[string]Sanitizing{",
  (string) (len=63) "\t_SanitizingName[0:11]:                   SanitizingTestHyphen,",
  (string) (len=63) "\tstrings.ToLower(_SanitizingName[0:11]):  SanitizingTestHyphen,",
  (string) (len=64) "\t_SanitizingName[11:23]:                  SanitizingHyphenStart,",
  (string) (len=64) "\tstrings.ToLower(_SanitizingName[11:23]): SanitizingHyphenStart,",
  (string) (len=69) "\t_SanitizingName[23:39]:                  Sanitizing_UnderscoreFirst,",
  (string) (len=69) "\tstrings.ToLower(_SanitizingName[23:39]): Sanitizing_UnderscoreFirst,",
  (string) (len=65) "\t_SanitizingName[39:51]:                  Sanitizing0NumberFirst,",
  (string) (len=65) "\tstrings.ToLower(_SanitizingName[39:51]): Sanitizing0NumberFirst,",
  (string) (len=63) "\t_SanitizingName[51:61]:                  Sanitizing123456789A,",
  (string) (len=63) "\tstrings.ToLower(_SanitizingName[51:61]): Sanitizing123456789A,",
  (string) (len=63) "\t_SanitizingName[61:72]:                  Sanitizing123123Asdf,",
  (string) (len=63) "\tstrings.ToLower(_SanitizingName[61:72]): Sanitizing123123Asdf,",
  (string) (len=65) "\t_SanitizingName[72:86]:                  SanitizingEndingHyphen,",
  (string) (len=65) "\tstrings.ToLower(_SanitizingName[72:86]): SanitizingEndingHyphen,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=64) "// ParseSanitizing attempts to convert a string to a Sanitizing.",
  (string) (len=55) "func ParseSanitizing(name string) (Sanitizing, error) {",
  (string) (len=41) "\tif x, ok := _SanitizingValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=58) "\tif x, ok := _SanitizingValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=73) "\treturn Sanitizing(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidSanitizing)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=85) "// MustParseSanitizing converts a string to a Sanitizing, and panics if is not valid.",
  (string) (len=50) "func MustParseSanitizing(name string) Sanitizing {",
  (string) (len=34) "\tval, err := ParseSanitizing(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=51) "func (x Sanitizing) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=55) "func (x *Sanitizing) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=34) "\ttmp, err := ParseSanitizing(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=96) "var errSanitizingNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=58) "func (x *Sanitizing) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=20) "\t\t*x = Sanitizing(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=20) "\t\t*x = Sanitizing(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=30) "\t\t*x, err = ParseSanitizing(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=38) "\t\t*x, err = ParseSanitizing(string(v))",
  (string) (len=17) "\tcase Sanitizing:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=20) "\t\t*x = Sanitizing(v)",
  (string) (len=18) "\tcase *Sanitizing:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=29) "\t\t\treturn errSanitizingNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=20) "\t\t*x = Sanitizing(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=20) "\t\t*x = Sanitizing(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=29) "\t\t\treturn errSanitizingNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=21) "\t\t*x = Sanitizing(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=29) "\t\t\treturn errSanitizingNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=21) "\t\t*x = Sanitizing(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=20) "\t\t*x = Sanitizing(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=29) "\t\t\treturn errSanitizingNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=21) "\t\t*x = Sanitizing(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=29) "\t\t\treturn errSanitizingNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=21) "\t\t*x = Sanitizing(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=29) "\t\t\treturn errSanitizingNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=21) "\t\t*x = Sanitizing(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=29) "\t\t\treturn errSanitizingNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=31) "\t\t*x, err = ParseSanitizing(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=51) "func (x Sanitizing) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=36) "func ParseSanitizingExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=36) "\t// SodaCoke is a Soda of type Coke.",
  (string) (len=21) "\tSodaCoke Soda = iota",
  (string) (len=38) "\t// SodaPepsi is a Soda of type Pepsi.",
  (string) (len=10) "\tSodaPepsi",
  (string) (len=40) "\t// SodaMtnDew is a Soda of type MtnDew.",
  (string) (len=11) "\tSodaMtnDew",
  (string) (len=1) ")",
  (string) "",
  (string) (len=93) "var ErrInvalidSoda = fmt.Errorf(\"not a valid Soda, try [%s]\", strings.Join(_SodaNames, \", \"))",
  (string) "",
  (string) (len=35) "const _SodaName = \"cokepepsimtndew\"",
  (string) "",
  (string) (len=26) "var _SodaNames = []string{",
  (string) (len=16) "\t_SodaName[0:4],",
  (string) (len=16) "\t_SodaName[4:9],",
  (string) (len=17) "\t_SodaName[9:15],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=62) "// SodaNames returns a list of possible string values of Soda.",
  (string) (len=27) "func SodaNames() []string {",
  (string) (len=39) "\ttmp := make([]string, len(_SodaNames))",
  (string) (len=22) "\tcopy(tmp, _SodaNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=31) "var _SodaMap = map[Soda]string{",
  (string) (len=28) "\tSodaCoke:   _SodaName[0:4],",
  (string) (len=28) "\tSodaPepsi:  _SodaName[4:9],",
  (string) (len=29) "\tSodaMtnDew: _SodaName[9:15],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=31) "func (x Soda) String() string {",
  (string) (len=32) "\tif str, ok := _SodaMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=34) "\treturn fmt.Sprintf(\"Soda(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=30) "func (x Soda) IsValid() bool {",
  (string) (len=21) "\t_, ok := _SodaMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=33) "var _SodaValue = map[string]Soda{",
  (string) (len=44) "\t_SodaName[0:4]:                   SodaCoke,",
  (string) (len=44) "\tstrings.ToLower(_SodaName[0:4]):  SodaCoke,",
  (string) (len=45) "\t_SodaName[4:9]:                   SodaPepsi,",
  (string) (len=45) "\tstrings.ToLower(_SodaName[4:9]):  SodaPepsi,",
  (string) (len=46) "\t_SodaName[9:15]:                  SodaMtnDew,",
  (string) (len=46) "\tstrings.ToLower(_SodaName[9:15]): SodaMtnDew,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=52) "// ParseSoda attempts to convert a string to a Soda.",
  (string) (len=43) "func ParseSoda(name string) (Soda, error) {",
  (string) (len=35) "\tif x, ok := _SodaValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=52) "\tif x, ok := _SodaValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=61) "\treturn Soda(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidSoda)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=73) "// MustParseSoda converts a string to a Soda, and panics if is not valid.",
  (string) (len=38) "func MustParseSoda(name string) Soda {",
  (string) (len=28) "\tval, err := ParseSoda(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=45) "func (x Soda) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=49) "func (x *Soda) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=28) "\ttmp, err := ParseSoda(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=90) "var errSodaNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=52) "func (x *Soda) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=14) "\t\t*x = Soda(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=14) "\t\t*x = Soda(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=24) "\t\t*x, err = ParseSoda(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=32) "\t\t*x, err = ParseSoda(string(v))",
  (string) (len=11) "\tcase Soda:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=14) "\t\t*x = Soda(v)",
  (string) (len=12) "\tcase *Soda:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=23) "\t\t\treturn errSodaNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=14) "\t\t*x = Soda(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=14) "\t\t*x = Soda(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=23) "\t\t\treturn errSodaNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=15) "\t\t*x = Soda(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=23) "\t\t\treturn errSodaNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=15) "\t\t*x = Soda(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=14) "\t\t*x = Soda(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=23) "\t\t\treturn errSodaNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=15) "\t\t*x = Soda(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=23) "\t\t\treturn errSodaNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=15) "\t\t*x = Soda(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=23) "\t\t\treturn errSodaNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=15) "\t\t*x = Soda(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=23) "\t\t\treturn errSodaNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=25) "\t\t*x, err = ParseSoda(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=45) "func (x Soda) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=30) "func ParseSodaExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=68) "\t// StartNotZeroStartWithNum is a StartNotZero of type StartWithNum.",
  (string) (len=50) "\tStartNotZeroStartWithNum StartNotZero = iota + 23",
  (string) (len=58) "\t// StartNotZeroNextNum is a StartNotZero of type NextNum.",
  (string) (len=20) "\tStartNotZeroNextNum",
  (string) (len=1) ")",
  (string) "",
  (string) (len=117) "var ErrInvalidStartNotZero = fmt.Errorf(\"not a valid StartNotZero, try [%s]\", strings.Join(_StartNotZeroNames, \", \"))",
  (string) "",
  (string) (len=47) "const _StartNotZeroName = \"startwithnumnextnum\"",
  (string) "",
  (string) (len=34) "var _StartNotZeroNames = []string{",
  (string) (len=25) "\t_StartNotZeroName[0:12],",
  (string) (len=26) "\t_StartNotZeroName[12:19],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=78) "// StartNotZeroNames returns a list of possible string values of StartNotZero.",
  (string) (len=35) "func StartNotZeroNames() []string {",
  (string) (len=47) "\ttmp := make([]string, len(_StartNotZeroNames))",
  (string) (len=30) "\tcopy(tmp, _StartNotZeroNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=47) "var _StartNotZeroMap = map[StartNotZero]string{",
  (string) (len=51) "\tStartNotZeroStartWithNum: _StartNotZeroName[0:12],",
  (string) (len=52) "\tStartNotZeroNextNum:      _StartNotZeroName[12:19],",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=39) "func (x StartNotZero) String() string {",
  (string) (len=40) "\tif str, ok := _StartNotZeroMap[x]; ok {",
  (string) (len=12) "\t\treturn str",
  (string) (len=2) "\t}",
  (string) (len=42) "\treturn fmt.Sprintf(\"StartNotZero(%d)\", x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=38) "func (x StartNotZero) IsValid() bool {",
  (string) (len=29) "\t_, ok := _StartNotZeroMap[x]",
  (string) (len=10) "\treturn ok",
  (string) (len=1) "}",
  (string) "",
  (string) (len=49) "var _StartNotZeroValue = map[string]StartNotZero{",
  (string) (len=69) "\t_StartNotZeroName[0:12]:                   StartNotZeroStartWithNum,",
  (string) (len=69) "\tstrings.ToLower(_StartNotZeroName[0:12]):  StartNotZeroStartWithNum,",
  (string) (len=64) "\t_StartNotZeroName[12:19]:                  StartNotZeroNextNum,",
  (string) (len=64) "\tstrings.ToLower(_StartNotZeroName[12:19]): StartNotZeroNextNum,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=68) "// ParseStartNotZero attempts to convert a string to a StartNotZero.",
  (string) (len=59) "func ParseStartNotZero(name string) (StartNotZero, error) {",
  (string) (len=43) "\tif x, ok := _StartNotZeroValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=60) "\tif x, ok := _StartNotZeroValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=77) "\treturn StartNotZero(0), fmt.Errorf(\"%s is %w\", name, ErrInvalidStartNotZero)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=89) "// MustParseStartNotZero converts a string to a StartNotZero, and panics if is not valid.",
  (string) (len=54) "func MustParseStartNotZero(name string) StartNotZero {",
  (string) (len=36) "\tval, err := ParseStartNotZero(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=53) "func (x StartNotZero) MarshalText() ([]byte, error) {",
  (string) (len=31) "\treturn []byte(x.String()), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=57) "func (x *StartNotZero) UnmarshalText(text []byte) error {",
  (string) (len=21) "\tname := string(text)",
  (string) (len=36) "\ttmp, err := ParseStartNotZero(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=98) "var errStartNotZeroNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=60) "func (x *StartNotZero) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=22) "\t\t*x = StartNotZero(0)",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=12) "\tcase int64:",
  (string) (len=22) "\t\t*x = StartNotZero(v)",
  (string) (len=13) "\tcase string:",
  (string) (len=32) "\t\t*x, err = ParseStartNotZero(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=40) "\t\t*x, err = ParseStartNotZero(string(v))",
  (string) (len=19) "\tcase StartNotZero:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=10) "\tcase int:",
  (string) (len=22) "\t\t*x = StartNotZero(v)",
  (string) (len=20) "\tcase *StartNotZero:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=31) "\t\t\treturn errStartNotZeroNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=11) "\tcase uint:",
  (string) (len=22) "\t\t*x = StartNotZero(v)",
  (string) (len=13) "\tcase uint64:",
  (string) (len=22) "\t\t*x = StartNotZero(v)",
  (string) (len=11) "\tcase *int:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=31) "\t\t\treturn errStartNotZeroNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=23) "\t\t*x = StartNotZero(*v)",
  (string) (len=13) "\tcase *int64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=31) "\t\t\treturn errStartNotZeroNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=23) "\t\t*x = StartNotZero(*v)",
  (string) (len=72) "\tcase float64: // json marshals everything as a float64 if it's a number",
  (string) (len=22) "\t\t*x = StartNotZero(v)",
  (string) (len=73) "\tcase *float64: // json marshals everything as a float64 if it's a number",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=31) "\t\t\treturn errStartNotZeroNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=23) "\t\t*x = StartNotZero(*v)",
  (string) (len=12) "\tcase *uint:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=31) "\t\t\treturn errStartNotZeroNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=23) "\t\t*x = StartNotZero(*v)",
  (string) (len=14) "\tcase *uint64:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=31) "\t\t\treturn errStartNotZeroNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=23) "\t\t*x = StartNotZero(*v)",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=31) "\t\t\treturn errStartNotZeroNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=33) "\t\t*x, err = ParseStartNotZero(*v)",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=53) "func (x StartNotZero) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=38) "func ParseStartNotZeroExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) "",
  (string) (len=7) "const (",
  (string) (len=52) "\t// StringEnumRandom is a StringEnum of type random.",
  (string) (len=39) "\tStringEnumRandom StringEnum = \"random\"",
  (string) (len=52) "\t// StringEnumValues is a StringEnum of type values.",
  (string) (len=39) "\tStringEnumValues StringEnum = \"values\"",
  (string) (len=48) "\t// StringEnumHere is a StringEnum of type here.",
  (string) (len=35) "\tStringEnumHere StringEnum = \"here\"",
  (string) (len=1) ")",
  (string) "",
  (string) (len=111) "var ErrInvalidStringEnum = fmt.Errorf(\"not a valid StringEnum, try [%s]\", strings.Join(_StringEnumNames, \", \"))",
  (string) "",
  (string) (len=32) "var _StringEnumNames = []string{",
  (string) (len=26) "\tstring(StringEnumRandom),",
  (string) (len=26) "\tstring(StringEnumValues),",
  (string) (len=24) "\tstring(StringEnumHere),",
  (string) (len=1) "}",
  (string) "",
  (string) (len=74) "// StringEnumNames returns a list of possible string values of StringEnum.",
  (string) (len=33) "func StringEnumNames() []string {",
  (string) (len=45) "\ttmp := make([]string, len(_StringEnumNames))",
  (string) (len=28) "\tcopy(tmp, _StringEnumNames)",
  (string) (len=11) "\treturn tmp",
  (string) (len=1) "}",
  (string) "",
  (string) (len=44) "// String implements the Stringer interface.",
  (string) (len=37) "func (x StringEnum) String() string {",
  (string) (len=17) "\treturn string(x)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=66) "// IsValid provides a quick way to determine if the typed value is",
  (string) (len=40) "// part of the allowed enumerated values",
  (string) (len=36) "func (x StringEnum) IsValid() bool {",
  (string) (len=37) "\t_, err := ParseStringEnum(string(x))",
  (string) (len=18) "\treturn err == nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=45) "var _StringEnumValue = map[string]StringEnum{",
  (string) (len=28) "\t\"random\": StringEnumRandom,",
  (string) (len=28) "\t\"values\": StringEnumValues,",
  (string) (len=26) "\t\"here\":   StringEnumHere,",
  (string) (len=1) "}",
  (string) "",
  (string) (len=64) "// ParseStringEnum attempts to convert a string to a StringEnum.",
  (string) (len=55) "func ParseStringEnum(name string) (StringEnum, error) {",
  (string) (len=41) "\tif x, ok := _StringEnumValue[name]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=121) "\t// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.",
  (string) (len=58) "\tif x, ok := _StringEnumValue[strings.ToLower(name)]; ok {",
  (string) (len=15) "\t\treturn x, nil",
  (string) (len=2) "\t}",
  (string) (len=74) "\treturn StringEnum(\"\"), fmt.Errorf(\"%s is %w\", name, ErrInvalidStringEnum)",
  (string) (len=1) "}",
  (string) "",
  (string) (len=85) "// MustParseStringEnum converts a string to a StringEnum, and panics if is not valid.",
  (string) (len=50) "func MustParseStringEnum(name string) StringEnum {",
  (string) (len=34) "\tval, err := ParseStringEnum(name)",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\tpanic(err)",
  (string) (len=2) "\t}",
  (string) (len=11) "\treturn val",
  (string) (len=1) "}",
  (string) "",
  (string) (len=53) "// MarshalText implements the text marshaller method.",
  (string) (len=51) "func (x StringEnum) MarshalText() ([]byte, error) {",
  (string) (len=30) "\treturn []byte(string(x)), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=57) "// UnmarshalText implements the text unmarshaller method.",
  (string) (len=55) "func (x *StringEnum) UnmarshalText(text []byte) error {",
  (string) (len=42) "\ttmp, err := ParseStringEnum(string(text))",
  (string) (len=16) "\tif err != nil {",
  (string) (len=12) "\t\treturn err",
  (string) (len=2) "\t}",
  (string) (len=9) "\t*x = tmp",
  (string) (len=11) "\treturn nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=96) "var errStringEnumNilPtr = errors.New(\"value pointer is nil\") // one per type for package clashes",
  (string) "",
  (string) (len=41) "// Scan implements the Scanner interface.",
  (string) (len=58) "func (x *StringEnum) Scan(value interface{}) (err error) {",
  (string) (len=18) "\tif value == nil {",
  (string) (len=21) "\t\t*x = StringEnum(\"\")",
  (string) (len=8) "\t\treturn",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=37) "\t// A wider range of scannable types.",
  (string) (len=61) "\t// driver.Value values at the top of the list for expediency",
  (string) (len=27) "\tswitch v := value.(type) {",
  (string) (len=13) "\tcase string:",
  (string) (len=30) "\t\t*x, err = ParseStringEnum(v)",
  (string) (len=13) "\tcase []byte:",
  (string) (len=38) "\t\t*x, err = ParseStringEnum(string(v))",
  (string) (len=17) "\tcase StringEnum:",
  (string) (len=8) "\t\t*x = v",
  (string) (len=18) "\tcase *StringEnum:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=29) "\t\t\treturn errStringEnumNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=9) "\t\t*x = *v",
  (string) (len=14) "\tcase *string:",
  (string) (len=15) "\t\tif v == nil {",
  (string) (len=29) "\t\t\treturn errStringEnumNilPtr",
  (string) (len=3) "\t\t}",
  (string) (len=31) "\t\t*x, err = ParseStringEnum(*v)",
  (string) (len=9) "\tdefault:",
  (string) (len=50) "\t\treturn errors.New(\"invalid type for StringEnum\")",
  (string) (len=2) "\t}",
  (string) "",
  (string) (len=7) "\treturn",
  (string) (len=1) "}",
  (string) "",
  (string) (len=48) "// Value implements the driver Valuer interface.",
  (string) (len=51) "func (x StringEnum) Value() (driver.Value, error) {",
  (string) (len=23) "\treturn x.String(), nil",
  (string) (len=1) "}",
  (string) "",
  (string) (len=22) "// Additional template",
  (string) (len=36) "func ParseStringEnumExample() bool {",
  (string) (len=12) "\treturn true",
  (string) (len=1) "}",
  (string) ""
}
